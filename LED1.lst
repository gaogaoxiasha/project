Interrupt Vectors
    00000 940C 0221 JMP	__start|__text_start
    00006 940C 0276 JMP	_timer2_comp_isr
    00010 940C 0A21 JMP	_timer1_ovf_isr

Program Code (text area)
__start|__text_start:
    00221 E5CF      LDI	R28,0x5F
    00222 E0D4      LDI	R29,4
    00223 BFCD      OUT	0x3D,R28
    00224 BFDE      OUT	0x3E,R29
    00225 51CE      SUBI	R28,0x1E
    00226 40D0      SBCI	R29,0
    00227 EA0A      LDI	R16,0xAA
    00228 8308      ST	Y,R16
    00229 2400      CLR	R0
    0022A EFEA      LDI	R30,0xFA
    0022B E0F3      LDI	R31,3
    0022C E013      LDI	R17,3
    0022D 3FEC      CPI	R30,0xFC
    0022E 07F1      CPC	R31,R17
    0022F F011      BEQ	0x0232
    00230 9201      ST	Z+,R0
    00231 CFFB      RJMP	0x022D
    00232 8300      ST	Z,R16
    00233 EAE8      LDI	R30,0xA8
    00234 E0F0      LDI	R31,0
    00235 E6A0      LDI	R26,0x60
    00236 E0B0      LDI	R27,0
    00237 E014      LDI	R17,4
    00238 E000      LDI	R16,0
    00239 BF0B      OUT	0x3B,R16
    0023A 34E2      CPI	R30,0x42
    0023B 07F1      CPC	R31,R17
    0023C F021      BEQ	0x0241
    0023D 95C8      LPM
    0023E 9631      ADIW	R30,1
    0023F 920D      ST	X+,R0
    00240 CFF9      RJMP	0x023A
    00241 940E 03A0 CALL	_main
_exit:
    00243 CFFF      RJMP	_exit
FILE: C:\Users\HaiPiao\Desktop\附小实验\程序\project\main\main.c
(0001) //ICC-AVR application builder : 2014/7/22 19:16:57
(0002) // Target : M16
(0003) // Crystal: 7.3728Mhz
(0004) 
(0005) #include "../Headers/Includes.h"
(0006) 
(0007) #define Max_note      100
(0008) #define Max_note_1    126     
(0009) #define Max_note_2    338
(0010) #define Max_note_3    120
(0011) #define Max_note_4    112
(0012) 
(0013) unsigned int note_n = 0;
(0014) unsigned int int_n = 0;
(0015) INT16U distance_mm = 0;//距离
(0016) unsigned char play_on = 0;
(0017) int LED_N = 0;
(0018) 
(0019) int song=0;
(0020) int song_note = 0;
(0021) unsigned char *song_music;
(0022) 
(0023) void LEDOnBoardInit(void)
(0024) {
(0025)     DDRC |= (0x01<<6)|(0x01<<7);
_LEDOnBoardInit:
    00244 B384      IN	R24,0x14
    00245 6C80      ORI	R24,0xC0
    00246 BB84      OUT	0x14,R24
(0026) 	//PORTC |= (0x01<<6)|(0x01<<7);
(0027) 	PORTC &= ~((0x01<<6)|(0x01<<7));
    00247 B385      IN	R24,0x15
    00248 738F      ANDI	R24,0x3F
    00249 BB85      OUT	0x15,R24
    0024A 9508      RET
(0028) }
(0029) void SET_LED_D10(unsigned char state)
(0030) {
(0031)  	PORTC = PORTC&(~(0X01<<6))|(state<<6);
_SET_LED_D10:
  state                --> R16
    0024B 2E20      MOV	R2,R16
    0024C 0C22      LSL	R2
    0024D 0C22      LSL	R2
    0024E 0C22      LSL	R2
    0024F 0C22      LSL	R2
    00250 0C22      LSL	R2
    00251 0C22      LSL	R2
    00252 B385      IN	R24,0x15
    00253 7B8F      ANDI	R24,0xBF
    00254 2982      OR	R24,R2
    00255 BB85      OUT	0x15,R24
    00256 9508      RET
(0032) }
(0033) void SET_LED_D11(unsigned char state)
(0034) {
(0035)  	PORTC = PORTC&(~(0X01<<7))|(state<<7);
_SET_LED_D11:
  state                --> R16
    00257 2E20      MOV	R2,R16
    00258 0C22      LSL	R2
    00259 0C22      LSL	R2
    0025A 0C22      LSL	R2
    0025B 0C22      LSL	R2
    0025C 0C22      LSL	R2
    0025D 0C22      LSL	R2
    0025E 0C22      LSL	R2
    0025F B385      IN	R24,0x15
    00260 778F      ANDI	R24,0x7F
    00261 2982      OR	R24,R2
    00262 BB85      OUT	0x15,R24
    00263 9508      RET
(0036) }
(0037) unsigned int t[28] = {0,3824,3460,3036,2864,2552,2272,2024,0,0,0,     //中音0-7
(0038)                         1880,1702,1517,1431,1275,1136,1012,0,0,0,     //高音11-17   频率
(0039) 						7633,6802,6060,5730,5102,4545,4048};          //低音21-27
(0040) 						
(0041) unsigned int d[28] = {0, 105, 116, 132, 140, 157, 176, 198,0,0,0,     //中音0-7
(0042)                          209, 234, 263, 279, 313, 352, 395,0,0,0,     //高音11-17   节拍
(0043) 						  52,  58,  66,  70,  78,  88,  98};          //低音21-27
(0044) 
(0045) unsigned char music[Max_note] = { 5,4, 5,4, 6,8, 5,8,11,8, 7,16,
(0046)                                   5,4, 5,4, 6,8, 5,8,12,8,11,16,
(0047) 								  5,4, 5,4,15,8,13,8,11,8, 7,8, 6,16,
(0048) 								 14,4,14,4,13,8,11,8,12,8,11,16,
(0049) 								 5,4, 5,4, 6,8, 5,8,11,8, 7,16,
(0050)                                   5,4, 5,4, 6,8, 5,8,12,8,11,16,
(0051) 								  5,4, 5,4,15,8,13,8,11,8, 7,8, 6,16,
(0052) 								 14,4,14,4,13,8,11,8,12,8,11,16};//祝你生日快乐100
(0053) unsigned char music_1[Max_note_1] = { 3,4, 3,4, 4,4, 5,4, 5,4, 4,4, 3,4, 2,4, 1,4, 1,4, 2,4, 3,4, 3,6, 2,2, 2,8,  
(0054)                                      3,4, 3,4, 4,4, 5,4, 5,4, 4,4, 3,4, 2,4, 1,4, 1,4, 2,4, 3,4, 2,6 ,1,2, 1,8,
(0055) 								     2,4, 2,4, 3,4, 1,4, 2,4, 3,2, 4,2, 3,4, 1,4, 2,4, 3,2, 4,2, 3,4, 2,4, 1,4,
(0056) 								     2,4,25,4, 3,8, 3,4, 4,4, 5,4, 5,4, 4,4, 3,4, 4,2, 2,2, 1,4, 1,4, 2,4, 3,4,
(0057) 								     2,6, 1,2, 1,4};//欢乐颂126
(0058) 
(0059) unsigned char music_2[Max_note_2] = {15,4, 13,2, 14,2, 15,4, 13,2, 14,2, 15,2,  5,2,  6,2,  7,2, 11,2, 12,2, 13,2, 14,2,
(0060)                                      13,4, 11,2, 12,2, 13,4,  3,2,  4,2,  5,2,  6,2,  5,2,  4,2,  5,2,  3,2,  4,2,  5,2,
(0061) 								      4,4,  6,2,  5,2,  4,4,  3,2,  2,2,  3,2,  2,2,  1,2,  2,2,  3,2,  4,2,  5,2,  6,2,
(0062) 								      4,4,  6,2,  5,2,  6,4,  7,2, 11,2,  5,2,  6,2,  7,2, 11,2, 12,2, 13,2, 14,2, 15,2,
(0063) 								  
(0064) 								     15,4, 13,2, 14,2, 15,4, 13,2, 14,2, 15,2,  5,2,  6,2,  7,2, 11,2, 12,2, 13,2, 14,2,
(0065)                                      13,4, 11,2, 12,2, 13,4,  3,2,  4,2,  5,2,  6,2,  5,2,  4,2,  5,2, 11,2,  7,2, 11,2,
(0066) 								      6,4, 11,2,  7,2,  6,4,  5,2,  4,2,  5,2,  4,2,  3,2,  4,2,  5,2,  6,2,  7,2, 11,2,
(0067) 								      6,4, 11,2,  7,2, 11,4,  7,2, 11,2,  7,2,  6,2,  7,2, 11,2, 12,2, 13,2, 14,2, 15,2,
(0068) 								  
(0069) 								     13,4, 11,2, 12,2, 13,4, 12,2, 11,2, 12,2,  7,2, 11,2, 12,2, 13,2, 12,2, 11,2,  7,2,
(0070) 								     11,4,  6,2,  7,2, 11,4,  1,2,  2,2,  3,2,  4,2,  3,2,  2,2,  3,2, 11,2,  7,2, 11,2,
(0071) 								      6,4, 11,2,  7,2,  6,4,  5,2,  4,2,  5,2,  4,2,  3,2,  4,2,  5,2,  6,2,  7,2, 11,2,
(0072) 								      6,4, 11,2,  7,2, 11,4,  7,2,  6,2,  7,2, 11,2, 12,2, 11,2,  7,2, 11,2,  6,2,  7,2, 
(0073) 								     11,8};//卡农338 
(0074) 
(0075) 
(0076) unsigned char music_3[Max_note_3] = { 5,8,  3,4,  5,4, 11,16,  6,8, 11,8,  5,16, 5,8,  1,4, 2,4, 3,8,   2,4,   1,4,  2,32, 5,8,
(0077)                                       3,4,  5,4, 11,12, 7,4,   6,8, 11,8,  5,16, 5,8,  2,4, 3,4, 4,12, 27,4,   1,16, 1,16, 6,8,
(0078) 								     11,8, 11,16, 7,8,  6,4,   7,4, 11,16, 6,4,  7,4, 11,4, 6,4, 6,4,   5,4,   3,4,  1,4,  2,32, 
(0079) 								      5,8,  3,4,  5,4, 11,12,  7,4,  6,8, 11,8,  5,16, 5,8, 2,4, 3,4,   4,12, 27,4,  1,16, 1,16,};
(0080) 								     //送别120
(0081) 
(0082) unsigned char music_4[Max_note_4] = {25,6, 1,9, 1,3, 1,6, 3,6, 2,9, 1,3, 2,6, 3,6, 1,9,  1,3,  3,6,  5,6, 6,18,
(0083)                                       6,6, 5,9, 3,3, 3,6, 1,6, 2,9, 1,3, 2,6, 3,6, 1,9, 26,3, 26,6, 25,6, 1,18,
(0084) 									  6,6, 5,9, 3,3, 3,6, 1,6, 2,9, 1,3, 2,6, 6,6, 5,9,  3,3,  3,6,  5,6, 6,18,
(0085) 									 11,6, 5,9, 3,3, 3,6, 1,6, 2,9, 1,3, 2,6, 3,6, 1,9, 26,3, 26,6, 25,6, 1,18};
(0086) 								     //友谊地久天长112
(0087) 
(0088) 
(0089) void port_init(void)
(0090) {
(0091)  PORTA = 0x00;
_port_init:
    00264 2422      CLR	R2
    00265 BA2B      OUT	0x1B,R2
(0092)  DDRA  = 0x00;
    00266 BA2A      OUT	0x1A,R2
(0093)  PORTB = 0x00;
    00267 BA28      OUT	0x18,R2
(0094)  DDRB  = 0x00;
    00268 BA27      OUT	0x17,R2
(0095)  PORTC = 0x00; //m103 output only
    00269 BA25      OUT	0x15,R2
(0096)  DDRC  = 0x00;
    0026A BA24      OUT	0x14,R2
(0097)  PORTD = 0x00;
    0026B BA22      OUT	0x12,R2
(0098)  DDRD  = 0x00;
    0026C BA21      OUT	0x11,R2
    0026D 9508      RET
(0099)  }
(0100)  
(0101) /**/
(0102) //TIMER2 initialize - prescale:Stop
(0103) // WGM: CTC
(0104) // desired value: 1Hz
(0105) // actual value: Out of range
(0106) void timer2_init(void)
(0107) {
(0108)  TCCR2 = 0x00; //stop
_timer2_init:
    0026E 2422      CLR	R2
    0026F BC25      OUT	0x25,R2
(0109)  ASSR  = 0x00; //set async mode
    00270 BC22      OUT	0x22,R2
(0110)  TCNT2 = 0x00 ; //setup
    00271 BC24      OUT	0x24,R2
(0111)  OCR2  = 0x00 ;
    00272 BC23      OUT	0x23,R2
(0112)  TCCR2 = 0x18; //start
    00273 E188      LDI	R24,0x18
    00274 BD85      OUT	0x25,R24
    00275 9508      RET
_timer2_comp_isr:
    00276 921A      ST	-Y,R1
    00277 922A      ST	-Y,R2
    00278 923A      ST	-Y,R3
    00279 924A      ST	-Y,R4
    0027A 925A      ST	-Y,R5
    0027B 930A      ST	-Y,R16
    0027C 931A      ST	-Y,R17
    0027D 932A      ST	-Y,R18
    0027E 933A      ST	-Y,R19
    0027F 938A      ST	-Y,R24
    00280 939A      ST	-Y,R25
    00281 93AA      ST	-Y,R26
    00282 93EA      ST	-Y,R30
    00283 93FA      ST	-Y,R31
    00284 B61F      IN	R1,0x3F
    00285 921A      ST	-Y,R1
    00286 934A      ST	-Y,R20
    00287 935A      ST	-Y,R21
(0113) }
(0114) 
(0115) //32分频的情况下调试成功，晶振为7.3728MHz
(0116) #pragma interrupt_handler timer2_comp_isr:iv_TIM2_COMP
(0117) void timer2_comp_isr(void)
(0118) {
(0119)  //compare occured TCNT2=OCR2
(0120)  if (!play_on)
    00288 9020 0066 LDS	R2,play_on
    0028A 2022      TST	R2
    0028B F481      BNE	0x029C
(0121)  {
(0122)   note_n = 0;
    0028C 2422      CLR	R2
    0028D 2433      CLR	R3
    0028E 9230 0061 STS	note_n+1,R3
    00290 9220 0060 STS	note_n,R2
(0123)   int_n = 1;
    00292 E081      LDI	R24,1
    00293 E090      LDI	R25,0
    00294 9390 0063 STS	int_n+1,R25
    00296 9380 0062 STS	int_n,R24
(0124)   play_on = 1;
    00298 9380 0066 STS	play_on,R24
(0125)   DDRD  |= (1<<7);
    0029A 9A8F      SBI	0x11,7
(0126)  }
    0029B C0E4      RJMP	0x0380
(0127) else
(0128)  {    
(0129)   if (--int_n == 0)
    0029C 9180 0062 LDS	R24,int_n
    0029E 9190 0063 LDS	R25,int_n+1
    002A0 9701      SBIW	R24,1
    002A1 011C      MOVW	R2,R24
    002A2 9230 0063 STS	int_n+1,R3
    002A4 9220 0062 STS	int_n,R2
    002A6 3080      CPI	R24,0
    002A7 0789      CPC	R24,R25
    002A8 F009      BEQ	0x02AA
    002A9 C0D6      RJMP	0x0380
(0130)   {
(0131)    TCCR2 = 0x18;
    002AA E188      LDI	R24,0x18
    002AB BD85      OUT	0x25,R24
(0132)    if (note_n < song_note)                        //祝你生日快乐
    002AC 9020 006B LDS	R2,song_note
    002AE 9030 006C LDS	R3,song_note+1
    002B0 9040 0060 LDS	R4,note_n
    002B2 9050 0061 LDS	R5,note_n+1
    002B4 1442      CP	R4,R2
    002B5 0453      CPC	R5,R3
    002B6 F008      BCS	0x02B8
    002B7 C0C4      RJMP	0x037C
(0133)       {
(0134)        OCR2 = (t[song_music[note_n]]/30);	    //2KHz频率，在1M内部晶振下。OCR2为8位寄存器
    002B8 9020 03FA LDS	R2,song_music
    002BA 9030 03FB LDS	R3,song_music+1
    002BC 01F2      MOVW	R30,R4
    002BD 0DE2      ADD	R30,R2
    002BE 1DF3      ADC	R31,R3
    002BF 81E0      LD	R30,Z
    002C0 27FF      CLR	R31
    002C1 0FEE      LSL	R30
    002C2 1FFF      ROL	R31
    002C3 E68D      LDI	R24,0x6D
    002C4 E090      LDI	R25,0
    002C5 0FE8      ADD	R30,R24
    002C6 1FF9      ADC	R31,R25
    002C7 8100      LD	R16,Z
    002C8 8111      LDD	R17,Z+1
    002C9 E12E      LDI	R18,0x1E
    002CA E030      LDI	R19,0
    002CB 940E 0AED CALL	div16u
    002CD BD03      OUT	0x23,R16
(0135)        int_n = d[song_music[note_n]]/1.25;        //时间长短，主频越高，乘以越大的系数
    002CE 9020 03FA LDS	R2,song_music
    002D0 9030 03FB LDS	R3,song_music+1
    002D2 91E0 0060 LDS	R30,note_n
    002D4 91F0 0061 LDS	R31,note_n+1
    002D6 0DE2      ADD	R30,R2
    002D7 1DF3      ADC	R31,R3
    002D8 81E0      LD	R30,Z
    002D9 27FF      CLR	R31
    002DA 0FEE      LSL	R30
    002DB 1FFF      ROL	R31
    002DC EA85      LDI	R24,0xA5
    002DD E090      LDI	R25,0
    002DE 0FE8      ADD	R30,R24
    002DF 1FF9      ADC	R31,R25
    002E0 8100      LD	R16,Z
    002E1 8111      LDD	R17,Z+1
    002E2 940E 0C6D CALL	uint2fp
    002E4 0118      MOVW	R2,R16
    002E5 0129      MOVW	R4,R18
    002E6 E904      LDI	R16,0x94
    002E7 E010      LDI	R17,0
    002E8 940E 0C20 CALL	lpm32
    002EA 933A      ST	-Y,R19
    002EB 932A      ST	-Y,R18
    002EC 931A      ST	-Y,R17
    002ED 930A      ST	-Y,R16
    002EE 0181      MOVW	R16,R2
    002EF 0192      MOVW	R18,R4
    002F0 940E 0C9A CALL	fpdiv2
    002F2 940E 0C3B CALL	fpint
    002F4 9310 0063 STS	int_n+1,R17
    002F6 9300 0062 STS	int_n,R16
(0136)        note_n++;
    002F8 9180 0060 LDS	R24,note_n
    002FA 9190 0061 LDS	R25,note_n+1
    002FC 9601      ADIW	R24,1
    002FD 9390 0061 STS	note_n+1,R25
    002FF 9380 0060 STS	note_n,R24
(0137)        int_n = int_n * song_music[note_n];
    00301 9020 03FA LDS	R2,song_music
    00303 9030 03FB LDS	R3,song_music+1
    00305 01FC      MOVW	R30,R24
    00306 0DE2      ADD	R30,R2
    00307 1DF3      ADC	R31,R3
    00308 8120      LD	R18,Z
    00309 2733      CLR	R19
    0030A 940E 0B71 CALL	empy16s
    0030C 9310 0063 STS	int_n+1,R17
    0030E 9300 0062 STS	int_n,R16
(0138)        note_n++;         
    00310 9180 0060 LDS	R24,note_n
    00312 9190 0061 LDS	R25,note_n+1
    00314 9601      ADIW	R24,1
    00315 9390 0061 STS	note_n+1,R25
    00317 9380 0060 STS	note_n,R24
(0139) 	   
(0140) 	   //设置LED随着音乐进行变化
(0141) 	   LED_N = note_n/16;
    00319 011C      MOVW	R2,R24
    0031A 9436      LSR	R3
    0031B 9427      ROR	R2
    0031C 9436      LSR	R3
    0031D 9427      ROR	R2
    0031E 9436      LSR	R3
    0031F 9427      ROR	R2
    00320 9436      LSR	R3
    00321 9427      ROR	R2
    00322 9230 0068 STS	LED_N+1,R3
    00324 9220 0067 STS	LED_N,R2
(0142) 	   switch(LED_N%2)
    00326 E022      LDI	R18,2
    00327 E030      LDI	R19,0
    00328 0181      MOVW	R16,R2
    00329 940E 0ACD CALL	mod16s
    0032B 01A8      MOVW	R20,R16
    0032C 3000      CPI	R16,0
    0032D 0701      CPC	R16,R17
    0032E F029      BEQ	0x0334
    0032F 3001      CPI	R16,1
    00330 E0E0      LDI	R30,0
    00331 071E      CPC	R17,R30
    00332 F121      BEQ	0x0357
    00333 C045      RJMP	0x0379
(0143) 	   {
(0144) 	    case 0:
(0145) 		{
(0146) 		 PORTB |= 0xFF;
    00334 B388      IN	R24,0x18
    00335 6F8F      ORI	R24,0xFF
    00336 BB88      OUT	0x18,R24
(0147) 		 PORTB &= ~(1<<((note_n-16*LED_N)/2));
    00337 9120 0067 LDS	R18,LED_N
    00339 9130 0068 LDS	R19,LED_N+1
    0033B E100      LDI	R16,0x10
    0033C E010      LDI	R17,0
    0033D 940E 0B71 CALL	empy16s
    0033F 9120 0060 LDS	R18,note_n
    00341 9130 0061 LDS	R19,note_n+1
    00343 1B20      SUB	R18,R16
    00344 0B31      SBC	R19,R17
    00345 9536      LSR	R19
    00346 9527      ROR	R18
    00347 E001      LDI	R16,1
    00348 E010      LDI	R17,0
    00349 940E 0C34 CALL	lsl16
    0034B 0118      MOVW	R2,R16
    0034C 9420      COM	R2
    0034D 9430      COM	R3
    0034E B248      IN	R4,0x18
    0034F 2455      CLR	R5
    00350 2042      AND	R4,R2
    00351 2053      AND	R5,R3
    00352 BA48      OUT	0x18,R4
(0148) 		 PORTD |= 0XFF;
    00353 B382      IN	R24,0x12
    00354 6F8F      ORI	R24,0xFF
    00355 BB82      OUT	0x12,R24
(0149) 		};break;
    00356 C022      RJMP	0x0379
(0150) 		case 1:
(0151) 		{
(0152) 		 PORTB |= 0xFF;
    00357 B388      IN	R24,0x18
    00358 6F8F      ORI	R24,0xFF
    00359 BB88      OUT	0x18,R24
(0153) 		 PORTD |= 0XFF;
    0035A B382      IN	R24,0x12
    0035B 6F8F      ORI	R24,0xFF
    0035C BB82      OUT	0x12,R24
(0154) 		 PORTD &= ~(1<<((note_n-16*LED_N)/2));
    0035D 9120 0067 LDS	R18,LED_N
    0035F 9130 0068 LDS	R19,LED_N+1
    00361 E100      LDI	R16,0x10
    00362 E010      LDI	R17,0
    00363 940E 0B71 CALL	empy16s
    00365 9120 0060 LDS	R18,note_n
    00367 9130 0061 LDS	R19,note_n+1
    00369 1B20      SUB	R18,R16
    0036A 0B31      SBC	R19,R17
    0036B 9536      LSR	R19
    0036C 9527      ROR	R18
    0036D E001      LDI	R16,1
    0036E E010      LDI	R17,0
    0036F 940E 0C34 CALL	lsl16
    00371 0118      MOVW	R2,R16
    00372 9420      COM	R2
    00373 9430      COM	R3
    00374 B242      IN	R4,0x12
    00375 2455      CLR	R5
    00376 2042      AND	R4,R2
    00377 2053      AND	R5,R3
    00378 BA42      OUT	0x12,R4
(0155) 		};break;		
(0156) 		default: break;
(0157) 	   }
(0158) 	   
(0159) 	  // TCCR2 = 0x1B;//32分频
(0160) 	   TCCR2 = 0x1C;//128分频 
    00379 E18C      LDI	R24,0x1C
    0037A BD85      OUT	0x25,R24
(0161)       }
    0037B C004      RJMP	0x0380
(0162)     else
(0163)       {
(0164)        play_on = 0;
    0037C 2422      CLR	R2
    0037D 9220 0066 STS	play_on,R2
(0165)        DDRD  &= ~(1<<7);
    0037F 988F      CBI	0x11,7
(0166)       }		   
(0167)   }
(0168)  }  
    00380 9159      LD	R21,Y+
    00381 9149      LD	R20,Y+
    00382 9019      LD	R1,Y+
    00383 BE1F      OUT	0x3F,R1
    00384 91F9      LD	R31,Y+
    00385 91E9      LD	R30,Y+
    00386 91A9      LD	R26,Y+
    00387 9199      LD	R25,Y+
    00388 9189      LD	R24,Y+
    00389 9139      LD	R19,Y+
    0038A 9129      LD	R18,Y+
    0038B 9119      LD	R17,Y+
    0038C 9109      LD	R16,Y+
    0038D 9059      LD	R5,Y+
    0038E 9049      LD	R4,Y+
    0038F 9039      LD	R3,Y+
    00390 9029      LD	R2,Y+
    00391 9019      LD	R1,Y+
    00392 9518      RETI
(0169) }
(0170) 
(0171) //call this routine to initialize all peripherals
(0172) void init_devices(void)
(0173) {
(0174)  //stop errant interrupts until set up
(0175)  CLI(); //disable all interrupts
_init_devices:
    00393 94F8      BCLR	7
(0176)  port_init(); 
    00394 DECF      RCALL	_port_init
(0177)  LEDOnBoardInit();
    00395 DEAE      RCALL	_LEDOnBoardInit
(0178)  init_7279(); 
    00396 940E 05A4 CALL	_init_7279
(0179)  timer2_init();
    00398 DED5      RCALL	_timer2_init
(0180)   
(0181)  MCUCR = 0x00;
    00399 2422      CLR	R2
    0039A BE25      OUT	0x35,R2
(0182)  GICR  = 0x00;
    0039B BE2B      OUT	0x3B,R2
(0183)  TIMSK = 0x80; //timer interrupt sources
    0039C E880      LDI	R24,0x80
    0039D BF89      OUT	0x39,R24
(0184)  SEI(); //re-enable interrupts
    0039E 9478      BSET	7
    0039F 9508      RET
_main:
  CH                   --> R22
  temp_yz              --> R10
  led                  --> R20
  temp                 --> R20
    003A0 9726      SBIW	R28,6
(0185)  //all peripherals are now initialized
(0186) }
(0187) 
(0188) void main(void)
(0189) {
(0190)   int temp,temp_yz;
(0191)   int CH;
(0192)   int led=0; 
    003A1 2744      CLR	R20
    003A2 2755      CLR	R21
(0193)   init_devices();
    003A3 DFEF      RCALL	_init_devices
(0194)   Delay_ms(20);      
    003A4 E104      LDI	R16,0x14
    003A5 E010      LDI	R17,0
    003A6 940E 09DD CALL	_Delay_ms
(0195)   
(0196) 
(0197)   /*
(0198)   */
(0199)   CH = get_data(0,0);
    003A8 2722      CLR	R18
    003A9 2700      CLR	R16
    003AA 940E 08EF CALL	_get_data
    003AC 01B8      MOVW	R22,R16
(0200)  // CH = 7;
(0201)   switch (CH)
    003AD 3000      CPI	R16,0
    003AE 0701      CPC	R16,R17
    003AF F121      BEQ	0x03D4
    003B0 3002      CPI	R16,2
    003B1 E0E0      LDI	R30,0
    003B2 071E      CPC	R17,R30
    003B3 F409      BNE	0x03B5
    003B4 C05A      RJMP	0x040F
    003B5 3004      CPI	R16,4
    003B6 E0E0      LDI	R30,0
    003B7 071E      CPC	R17,R30
    003B8 F409      BNE	0x03BA
    003B9 C055      RJMP	0x040F
    003BA 3005      CPI	R16,5
    003BB E0E0      LDI	R30,0
    003BC 071E      CPC	R17,R30
    003BD F409      BNE	0x03BF
    003BE C0CA      RJMP	0x0489
    003BF 3006      CPI	R16,6
    003C0 E0E0      LDI	R30,0
    003C1 071E      CPC	R17,R30
    003C2 F409      BNE	0x03C4
    003C3 C0EA      RJMP	0x04AE
    003C4 3007      CPI	R16,7
    003C5 E0E0      LDI	R30,0
    003C6 071E      CPC	R17,R30
    003C7 F409      BNE	0x03C9
    003C8 C0FB      RJMP	0x04C4
    003C9 3008      CPI	R16,0x8
    003CA E0E0      LDI	R30,0
    003CB 071E      CPC	R17,R30
    003CC F409      BNE	0x03CE
    003CD C10C      RJMP	0x04DA
    003CE 300D      CPI	R16,0xD
    003CF E0E0      LDI	R30,0
    003D0 071E      CPC	R17,R30
    003D1 F409      BNE	0x03D3
    003D2 C12A      RJMP	0x04FD
    003D3 C1C2      RJMP	0x0596
(0202)   {
(0203)    case 0://LED模式
(0204)      {	  
(0205) 	  DDRB = 0xFF;
    003D4 EF8F      LDI	R24,0xFF
    003D5 BB87      OUT	0x17,R24
(0206)       PORTB = 0XFF;
    003D6 BB88      OUT	0x18,R24
(0207)       DDRD = 0XFF;
    003D7 BB81      OUT	0x11,R24
(0208) 	  PORTD = 0XFF;
    003D8 BB82      OUT	0x12,R24
    003D9 C034      RJMP	0x040E
(0209)       
(0210) 	  while(1)
(0211) 	  {
(0212) 	   if(led<8)
    003DA 3048      CPI	R20,0x8
    003DB E0E0      LDI	R30,0
    003DC 075E      CPC	R21,R30
    003DD F494      BGE	0x03F0
(0213) 	   {
(0214) 	    PORTD = 0XFF;
    003DE EF8F      LDI	R24,0xFF
    003DF BB82      OUT	0x12,R24
(0215) 		PORTB = ~(1<<led);
    003E0 E001      LDI	R16,1
    003E1 E010      LDI	R17,0
    003E2 019A      MOVW	R18,R20
    003E3 940E 0C34 CALL	lsl16
    003E5 0118      MOVW	R2,R16
    003E6 9420      COM	R2
    003E7 9430      COM	R3
    003E8 BA28      OUT	0x18,R2
(0216) 		Delay_ms(200);
    003E9 EC08      LDI	R16,0xC8
    003EA E010      LDI	R17,0
    003EB 940E 09DD CALL	_Delay_ms
(0217) 		led++;
    003ED 5F4F      SUBI	R20,0xFF
    003EE 4F5F      SBCI	R21,0xFF
(0218) 	   }
    003EF C01E      RJMP	0x040E
(0219) 	   else if((led>=8)&&(led<16))
    003F0 3048      CPI	R20,0x8
    003F1 E0E0      LDI	R30,0
    003F2 075E      CPC	R21,R30
    003F3 F0C4      BLT	0x040C
    003F4 3140      CPI	R20,0x10
    003F5 E0E0      LDI	R30,0
    003F6 075E      CPC	R21,R30
    003F7 F4A4      BGE	0x040C
(0220) 	   {
(0221) 	    PORTB = 0XFF;
    003F8 EF8F      LDI	R24,0xFF
    003F9 BB88      OUT	0x18,R24
(0222) 		PORTD = ~(1<<(led-8));
    003FA 019A      MOVW	R18,R20
    003FB 5028      SUBI	R18,0x8
    003FC 4030      SBCI	R19,0
    003FD E001      LDI	R16,1
    003FE E010      LDI	R17,0
    003FF 940E 0C34 CALL	lsl16
    00401 0118      MOVW	R2,R16
    00402 9420      COM	R2
    00403 9430      COM	R3
    00404 BA22      OUT	0x12,R2
(0223) 		Delay_ms(200);
    00405 EC08      LDI	R16,0xC8
    00406 E010      LDI	R17,0
    00407 940E 09DD CALL	_Delay_ms
(0224) 		led++;
    00409 5F4F      SUBI	R20,0xFF
    0040A 4F5F      SBCI	R21,0xFF
(0225) 	   }
    0040B C002      RJMP	0x040E
(0226) 	   else
(0227) 	   {
(0228) 	    led=0;
    0040C 2744      CLR	R20
    0040D 2755      CLR	R21
    0040E CFCB      RJMP	0x03DA
(0229) 	   } 
(0230) 	  }	   
(0231) 	 };
(0232) 	 break;
(0233) 	 
(0234)    case 2://蜂鸣器模式
(0235)    
(0236)    
(0237) 	 
(0238)    case 4://温度传感器模式，显示温度值
(0239)      {
(0240) 	  dis_data(7,7,4);
    0040F E084      LDI	R24,4
    00410 8388      ST	Y,R24
    00411 E080      LDI	R24,0
    00412 8389      STD	Y+1,R24
    00413 838A      STD	Y+2,R24
    00414 838B      STD	Y+3,R24
    00415 E027      LDI	R18,7
    00416 E007      LDI	R16,7
    00417 940E 0854 CALL	_dis_data
(0241) 	  DS18B20Init();
    00419 940E 0944 CALL	_DS18B20Init
    0041B C06C      RJMP	0x0488
(0242) 	  while(1)
(0243) 	  {
(0244) 	   temp=gettemp();//读取到的温度数据
    0041C 940E 098E CALL	_gettemp
    0041E 01A8      MOVW	R20,R16
(0245)        Delay_ms(100);
    0041F E604      LDI	R16,0x64
    00420 E010      LDI	R17,0
    00421 940E 09DD CALL	_Delay_ms
(0246)    
(0247)        if(temp >= 0xf800)//如果为零下，求补码
    00423 3040      CPI	R20,0
    00424 EFE8      LDI	R30,0xF8
    00425 075E      CPC	R21,R30
    00426 F160      BCS	0x0453
(0248)        {
(0249)         temp = temp - 0XF800;   //去掉5个符号位
    00427 5040      SUBI	R20,0
    00428 4F58      SBCI	R21,0xF8
(0250) 	    temp = 0x800 - temp;    //求出补码
    00429 E080      LDI	R24,0
    0042A E098      LDI	R25,0x8
    0042B 1B84      SUB	R24,R20
    0042C 0B95      SBC	R25,R21
    0042D 01AC      MOVW	R20,R24
(0251) 	    temp = (temp*6.25)/10;  //计算温度值，应该乘0.0625，现在乘0.625可以显示一位小数位
    0042E E900      LDI	R16,0x90
    0042F E010      LDI	R17,0
    00430 940E 0C20 CALL	lpm32
    00432 0118      MOVW	R2,R16
    00433 0129      MOVW	R4,R18
    00434 018A      MOVW	R16,R20
    00435 940E 0C6F CALL	int2fp
    00437 933A      ST	-Y,R19
    00438 932A      ST	-Y,R18
    00439 931A      ST	-Y,R17
    0043A 930A      ST	-Y,R16
    0043B 0181      MOVW	R16,R2
    0043C 0192      MOVW	R18,R4
    0043D 940E 0E0A CALL	fpmule2
    0043F 0118      MOVW	R2,R16
    00440 0129      MOVW	R4,R18
    00441 E80C      LDI	R16,0x8C
    00442 E010      LDI	R17,0
    00443 940E 0C20 CALL	lpm32
    00445 933A      ST	-Y,R19
    00446 932A      ST	-Y,R18
    00447 931A      ST	-Y,R17
    00448 930A      ST	-Y,R16
    00449 0181      MOVW	R16,R2
    0044A 0192      MOVW	R18,R4
    0044B 940E 0C9A CALL	fpdiv2
    0044D 940E 0C3B CALL	fpint
    0044F 01A8      MOVW	R20,R16
(0252) 	    temp = (1000*16)+temp;	//在最高位显示负号
    00450 5840      SUBI	R20,0x80
    00451 4C51      SBCI	R21,0xC1
(0253) 	   }
    00452 C022      RJMP	0x0475
(0254)        else
(0255)        {
(0256)         temp = (temp*6.25)/10;//如果为正，补码为它本身，直接转换为温度值进行显示		
    00453 E900      LDI	R16,0x90
    00454 E010      LDI	R17,0
    00455 940E 0C20 CALL	lpm32
    00457 0118      MOVW	R2,R16
    00458 0129      MOVW	R4,R18
    00459 018A      MOVW	R16,R20
    0045A 940E 0C6F CALL	int2fp
    0045C 933A      ST	-Y,R19
    0045D 932A      ST	-Y,R18
    0045E 931A      ST	-Y,R17
    0045F 930A      ST	-Y,R16
    00460 0181      MOVW	R16,R2
    00461 0192      MOVW	R18,R4
    00462 940E 0E0A CALL	fpmule2
    00464 0118      MOVW	R2,R16
    00465 0129      MOVW	R4,R18
    00466 E80C      LDI	R16,0x8C
    00467 E010      LDI	R17,0
    00468 940E 0C20 CALL	lpm32
    0046A 933A      ST	-Y,R19
    0046B 932A      ST	-Y,R18
    0046C 931A      ST	-Y,R17
    0046D 930A      ST	-Y,R16
    0046E 0181      MOVW	R16,R2
    0046F 0192      MOVW	R18,R4
    00470 940E 0C9A CALL	fpdiv2
    00472 940E 0C3B CALL	fpint
    00474 01A8      MOVW	R20,R16
(0257)        }    
(0258) 	   dis_data_RP(0,3,temp,1);//显示温度值	   
    00475 E081      LDI	R24,1
    00476 E090      LDI	R25,0
    00477 839D      STD	Y+5,R25
    00478 838C      STD	Y+4,R24
    00479 011A      MOVW	R2,R20
    0047A 2444      CLR	R4
    0047B FC37      SBRC	R3,7
    0047C 9440      COM	R4
    0047D 2455      CLR	R5
    0047E FC47      SBRC	R4,7
    0047F 9450      COM	R5
    00480 8228      ST	Y,R2
    00481 8239      STD	Y+1,R3
    00482 824A      STD	Y+2,R4
    00483 825B      STD	Y+3,R5
    00484 E023      LDI	R18,3
    00485 2700      CLR	R16
    00486 940E 0899 CALL	_dis_data_RP
    00488 CF93      RJMP	0x041C
(0259) 	  }	   
(0260) 	 };
(0261) 	 break;
(0262) 	 
(0263) 	 case 5://温度传感器模式，显示温度值
(0264)      {
(0265) 	     HC_SR04_Init();
    00489 940E 0A0A CALL	_HC_SR04_Init
(0266) 		 CLI();
    0048B 94F8      BCLR	7
(0267) 		 timer1_init();
    0048C 940E 0A0E CALL	_timer1_init
(0268) 		 MCUCR = 0x00;
    0048E 2422      CLR	R2
    0048F BE25      OUT	0x35,R2
(0269)  		 GICR  = 0x00;
    00490 BE2B      OUT	0x3B,R2
(0270)  		 TIMSK |= (0x01<<2); //溢出中断使能
    00491 B789      IN	R24,0x39
    00492 6084      ORI	R24,4
    00493 BF89      OUT	0x39,R24
(0271) 		 SEI();
    00494 9478      BSET	7
    00495 C017      RJMP	0x04AD
(0272) 		 while(1)
(0273) 		 {
(0274) 		     
(0275) 		     distance_mm = (INT16U)GetDistance();//单位mm
    00496 940E 0A31 CALL	_GetDistance
    00498 940E 0C3B CALL	fpint
    0049A 9310 0065 STS	distance_mm+1,R17
    0049C 9300 0064 STS	distance_mm,R16
(0276) 			 dis_data(0,3,distance_mm);
    0049E 0118      MOVW	R2,R16
    0049F 2444      CLR	R4
    004A0 2455      CLR	R5
    004A1 8228      ST	Y,R2
    004A2 8239      STD	Y+1,R3
    004A3 824A      STD	Y+2,R4
    004A4 825B      STD	Y+3,R5
    004A5 E023      LDI	R18,3
    004A6 2700      CLR	R16
    004A7 940E 0854 CALL	_dis_data
(0277) 			 Delay_ms(100);
    004A9 E604      LDI	R16,0x64
    004AA E010      LDI	R17,0
    004AB 940E 09DD CALL	_Delay_ms
    004AD CFE8      RJMP	0x0496
(0278) 		 }
(0279) 	 }
(0280) 	 
(0281) 	 case 6:
(0282) 	 {
(0283)  		 MH_B_Init();
    004AE 940E 059E CALL	_MH_B_Init
(0284) 		 SET_LED_D11(1);
    004B0 E001      LDI	R16,1
    004B1 DDA5      RCALL	_SET_LED_D11
(0285) 		 Delay_ms(100);
    004B2 E604      LDI	R16,0x64
    004B3 E010      LDI	R17,0
    004B4 940E 09DD CALL	_Delay_ms
    004B6 C00C      RJMP	0x04C3
(0286) 	     while(1)
(0287)   		 {
(0288)       	    if(!Read_MH_B())
    004B7 940E 05A0 CALL	_Read_MH_B
    004B9 2300      TST	R16
    004BA F431      BNE	0x04C1
(0289) 	  		{
(0290)           	   SET_LED_D11(1);
    004BB E001      LDI	R16,1
    004BC DD9A      RCALL	_SET_LED_D11
(0291) 		   	   Delay_ms(20);
    004BD E104      LDI	R16,0x14
    004BE E010      LDI	R17,0
    004BF 940E 09DD CALL	_Delay_ms
(0292) 	  		}
(0293) 	  		SET_LED_D11(0);
    004C1 2700      CLR	R16
    004C2 DD94      RCALL	_SET_LED_D11
    004C3 CFF3      RJMP	0x04B7
(0294)   	     }
(0295) 	 };
(0296) 	 case 7:
(0297) 	 {	  	  
(0298) 	     FC04Init();
    004C4 940E 0598 CALL	_FC04Init
(0299) 		 SET_LED_D10(1);
    004C6 E001      LDI	R16,1
    004C7 DD83      RCALL	_SET_LED_D10
(0300) 		 Delay_ms(100);
    004C8 E604      LDI	R16,0x64
    004C9 E010      LDI	R17,0
    004CA 940E 09DD CALL	_Delay_ms
    004CC C00C      RJMP	0x04D9
(0301) 	     while(1)
(0302)   		 {
(0303)       	   if(!Read_FC04())
    004CD 940E 059A CALL	_Read_FC04
    004CF 2300      TST	R16
    004D0 F431      BNE	0x04D7
(0304) 	  	   {
(0305)              SET_LED_D10(1);
    004D1 E001      LDI	R16,1
    004D2 DD78      RCALL	_SET_LED_D10
(0306) 		  	 Delay_ms(20);
    004D3 E104      LDI	R16,0x14
    004D4 E010      LDI	R17,0
    004D5 940E 09DD CALL	_Delay_ms
(0307) 	       }
(0308) 	  	   SET_LED_D10(0);
    004D7 2700      CLR	R16
    004D8 DD72      RCALL	_SET_LED_D10
    004D9 CFF3      RJMP	0x04CD
(0309)   		 }
(0310) 	 };
(0311) 	 break;
(0312) 	 
(0313) 	 case 8:
(0314) 	 {	  	  
(0315) 	     MQ2_Init();
    004DA 940E 0A99 CALL	_MQ2_Init
(0316) 		 Delay_ms(100);
    004DC E604      LDI	R16,0x64
    004DD E010      LDI	R17,0
    004DE 940E 09DD CALL	_Delay_ms
    004E0 C01B      RJMP	0x04FC
(0317) 	     while(1)
(0318)   		 {
(0319)       	   if(!Read_MQ2_DO())
    004E1 940E 0AA4 CALL	_Read_MQ2_DO
    004E3 2EA0      MOV	R10,R16
    004E4 2300      TST	R16
    004E5 F431      BNE	0x04EC
(0320) 	  	   {
(0321)              SET_LED_D10(1);
    004E6 E001      LDI	R16,1
    004E7 DD63      RCALL	_SET_LED_D10
(0322) 		  	 Delay_ms(20);
    004E8 E104      LDI	R16,0x14
    004E9 E010      LDI	R17,0
    004EA 940E 09DD CALL	_Delay_ms
(0323) 	       }
(0324) 		   dis_data(0,3,Read_MQ2_AO());
    004EC 940E 0AA8 CALL	_Read_MQ2_AO
    004EE 0158      MOVW	R10,R16
    004EF 0115      MOVW	R2,R10
    004F0 2444      CLR	R4
    004F1 2455      CLR	R5
    004F2 8228      ST	Y,R2
    004F3 8239      STD	Y+1,R3
    004F4 824A      STD	Y+2,R4
    004F5 825B      STD	Y+3,R5
    004F6 E023      LDI	R18,3
    004F7 2700      CLR	R16
    004F8 940E 0854 CALL	_dis_data
(0325) 	  	   SET_LED_D10(0);
    004FA 2700      CLR	R16
    004FB DD4F      RCALL	_SET_LED_D10
    004FC CFE4      RJMP	0x04E1
(0326)   		 }
(0327) 	 };
(0328) 	 break;
(0329) 	 
(0330) 	 case 13://d 温度报警模式，设置阈值温度，超过温度进行报警
(0331)      {
(0332) 	  DS18B20Init();
    004FD 940E 0944 CALL	_DS18B20Init
(0333) 	  temp_yz = get_data(0,2);//温度阈值
    004FF E022      LDI	R18,2
    00500 2700      CLR	R16
    00501 940E 08EF CALL	_get_data
    00503 0158      MOVW	R10,R16
(0334) 	  temp_yz = temp_yz*10;	  
    00504 E00A      LDI	R16,0xA
    00505 E010      LDI	R17,0
    00506 0195      MOVW	R18,R10
    00507 940E 0B71 CALL	empy16s
    00509 0158      MOVW	R10,R16
    0050A C08A      RJMP	0x0595
(0335) 	  
(0336) 	  while(1)
(0337) 	  {
(0338) 	   temp=gettemp();//读取到的温度数据
    0050B 940E 098E CALL	_gettemp
    0050D 01A8      MOVW	R20,R16
(0339)        Delay_ms(100);
    0050E E604      LDI	R16,0x64
    0050F E010      LDI	R17,0
    00510 940E 09DD CALL	_Delay_ms
(0340) 	   
(0341)        if(temp >= 0xf800)//如果为零下，求补码
    00512 3040      CPI	R20,0
    00513 EFE8      LDI	R30,0xF8
    00514 075E      CPC	R21,R30
    00515 F160      BCS	0x0542
(0342)        {
(0343)         temp = temp - 0XF800;   //去掉5个符号位
    00516 5040      SUBI	R20,0
    00517 4F58      SBCI	R21,0xF8
(0344) 	    temp = 0x800 - temp;    //求出补码
    00518 E080      LDI	R24,0
    00519 E098      LDI	R25,0x8
    0051A 1B84      SUB	R24,R20
    0051B 0B95      SBC	R25,R21
    0051C 01AC      MOVW	R20,R24
(0345) 	    temp = (temp*6.25)/10;  //计算温度值，应该乘0.0625，现在乘0.625可以显示一位小数位
    0051D E900      LDI	R16,0x90
    0051E E010      LDI	R17,0
    0051F 940E 0C20 CALL	lpm32
    00521 0118      MOVW	R2,R16
    00522 0129      MOVW	R4,R18
    00523 018A      MOVW	R16,R20
    00524 940E 0C6F CALL	int2fp
    00526 933A      ST	-Y,R19
    00527 932A      ST	-Y,R18
    00528 931A      ST	-Y,R17
    00529 930A      ST	-Y,R16
    0052A 0181      MOVW	R16,R2
    0052B 0192      MOVW	R18,R4
    0052C 940E 0E0A CALL	fpmule2
    0052E 0118      MOVW	R2,R16
    0052F 0129      MOVW	R4,R18
    00530 E80C      LDI	R16,0x8C
    00531 E010      LDI	R17,0
    00532 940E 0C20 CALL	lpm32
    00534 933A      ST	-Y,R19
    00535 932A      ST	-Y,R18
    00536 931A      ST	-Y,R17
    00537 930A      ST	-Y,R16
    00538 0181      MOVW	R16,R2
    00539 0192      MOVW	R18,R4
    0053A 940E 0C9A CALL	fpdiv2
    0053C 940E 0C3B CALL	fpint
    0053E 01A8      MOVW	R20,R16
(0346) 	    temp = (1000*16)+temp;	//在最高位显示负号
    0053F 5840      SUBI	R20,0x80
    00540 4C51      SBCI	R21,0xC1
(0347) 	   }
    00541 C022      RJMP	0x0564
(0348)        else
(0349)        {
(0350)         temp = (temp*6.25)/10;//如果为正，补码为它本身，直接转换为温度值进行显示		
    00542 E900      LDI	R16,0x90
    00543 E010      LDI	R17,0
    00544 940E 0C20 CALL	lpm32
    00546 0118      MOVW	R2,R16
    00547 0129      MOVW	R4,R18
    00548 018A      MOVW	R16,R20
    00549 940E 0C6F CALL	int2fp
    0054B 933A      ST	-Y,R19
    0054C 932A      ST	-Y,R18
    0054D 931A      ST	-Y,R17
    0054E 930A      ST	-Y,R16
    0054F 0181      MOVW	R16,R2
    00550 0192      MOVW	R18,R4
    00551 940E 0E0A CALL	fpmule2
    00553 0118      MOVW	R2,R16
    00554 0129      MOVW	R4,R18
    00555 E80C      LDI	R16,0x8C
    00556 E010      LDI	R17,0
    00557 940E 0C20 CALL	lpm32
    00559 933A      ST	-Y,R19
    0055A 932A      ST	-Y,R18
    0055B 931A      ST	-Y,R17
    0055C 930A      ST	-Y,R16
    0055D 0181      MOVW	R16,R2
    0055E 0192      MOVW	R18,R4
    0055F 940E 0C9A CALL	fpdiv2
    00561 940E 0C3B CALL	fpint
    00563 01A8      MOVW	R20,R16
(0351)        }/**/   	   
(0352)   
(0353)        if(temp > temp_yz)
    00564 16A4      CP	R10,R20
    00565 06B5      CPC	R11,R21
    00566 F41C      BGE	0x056A
(0354) 	   {
(0355) 	    PORTC |= (1<<6);PORTC |= (1<<7);	   
    00567 9AAE      SBI	0x15,6
    00568 9AAF      SBI	0x15,7
(0356) 	   }
    00569 C005      RJMP	0x056F
(0357) 	   else if(temp <= temp_yz)
    0056A 16A4      CP	R10,R20
    0056B 06B5      CPC	R11,R21
    0056C F014      BLT	0x056F
(0358) 	   {
(0359) 	    PORTC &= ~(1<<7);PORTC &= ~(1<<6);
    0056D 98AF      CBI	0x15,7
    0056E 98AE      CBI	0x15,6
(0360) 	   }	   
(0361) 	    
(0362) 	   dis_data_RP(0,3,temp,1);//显示温度值	  
    0056F E081      LDI	R24,1
    00570 E090      LDI	R25,0
    00571 839D      STD	Y+5,R25
    00572 838C      STD	Y+4,R24
    00573 011A      MOVW	R2,R20
    00574 2444      CLR	R4
    00575 FC37      SBRC	R3,7
    00576 9440      COM	R4
    00577 2455      CLR	R5
    00578 FC47      SBRC	R4,7
    00579 9450      COM	R5
    0057A 8228      ST	Y,R2
    0057B 8239      STD	Y+1,R3
    0057C 824A      STD	Y+2,R4
    0057D 825B      STD	Y+3,R5
    0057E E023      LDI	R18,3
    0057F 2700      CLR	R16
    00580 940E 0899 CALL	_dis_data_RP
(0363) 	   dis_data_RP(4,7,temp_yz,5);	   
    00582 E085      LDI	R24,5
    00583 E090      LDI	R25,0
    00584 839D      STD	Y+5,R25
    00585 838C      STD	Y+4,R24
    00586 0115      MOVW	R2,R10
    00587 2444      CLR	R4
    00588 FC37      SBRC	R3,7
    00589 9440      COM	R4
    0058A 2455      CLR	R5
    0058B FC47      SBRC	R4,7
    0058C 9450      COM	R5
    0058D 8228      ST	Y,R2
    0058E 8239      STD	Y+1,R3
    0058F 824A      STD	Y+2,R4
    00590 825B      STD	Y+3,R5
    00591 E027      LDI	R18,7
    00592 E004      LDI	R16,4
    00593 940E 0899 CALL	_dis_data_RP
    00595 CF75      RJMP	0x050B
    00596 9626      ADIW	R28,6
    00597 9508      RET
FILE: C:\Users\HaiPiao\Desktop\附小实验\程序\project\FC04\FC04.c
(0001) /*******************************************************************************
(0002) **  MCU        : ATmega16 (Atmel)
(0003) **  Compiler   : ICCAVR 7.22
(0004) **  Module Name: FC4.c
(0005) **  Module Date: 2015-10-16
(0006) **  Module Auth: 蔡海飘
(0007) **  Description: 咪头
(0008) **  Version    : V1.0
(0009) **  Notes      : 
(0010) **------------------------------------------------------------------------------
(0011) /*----------------------------  I N C L U D E S  -----------------------------*/
(0012) #include "FC04.h"
(0013) 
(0014) /*--------------------------  D E F I N I T I O N  ---------------------------*/
(0015) 
(0016) /*---------------------------  F U N C T I O N S  ----------------------------*/
(0017) void FC04Init(void)
(0018) {
(0019)  	 DDRD &= ~(0x01<<1);
_FC04Init:
    00598 9889      CBI	0x11,1
    00599 9508      RET
(0020) }  
(0021) 
(0022) unsigned char Read_FC04(void)  
(0023) {
(0024)     unsigned char state = 0;
_Read_FC04:
  state                --> R16
    0059A 2700      CLR	R16
(0025) 	state = PIND&(0x01<<1);
    0059B B300      IN	R16,0x10
    0059C 7002      ANDI	R16,2
(0026) 	return state;
    0059D 9508      RET
FILE: C:\Users\HaiPiao\Desktop\附小实验\程序\project\MH_B\MH_B.c
(0001) /*******************************************************************************
(0002) **  MCU        : ATmega16 (Atmel)
(0003) **  Compiler   : ICCAVR 7.22
(0004) **  Module Name: MH_B.c
(0005) **  Module Date: 2015-10-16
(0006) **  Module Auth: 蔡海飘
(0007) **  Description: 红外传感器
(0008) **  Version    : V1.0
(0009) **  Notes      : 
(0010) **------------------------------------------------------------------------------
(0011) /*----------------------------  I N C L U D E S  -----------------------------*/
(0012) #include "MH_B.h"
(0013) 
(0014) /*--------------------------  D E F I N I T I O N  ---------------------------*/
(0015) 
(0016) /*---------------------------  F U N C T I O N S  ----------------------------*/
(0017) void MH_B_Init(void)
(0018) {
(0019)  	 DDRA &= ~(0x01<<6);
_MH_B_Init:
    0059E 98D6      CBI	0x1A,6
    0059F 9508      RET
(0020) }  
(0021) 
(0022) unsigned char Read_MH_B(void)  
(0023) {
(0024)     unsigned char state = 0;
_Read_MH_B:
  state                --> R16
    005A0 2700      CLR	R16
(0025) 	state = PINA&(0x01<<6);
    005A1 B309      IN	R16,0x19
    005A2 7400      ANDI	R16,0x40
(0026) 	return state;
    005A3 9508      RET
_init_7279:
  tmr                  --> R20
    005A4 934A      ST	-Y,R20
    005A5 935A      ST	-Y,R21
FILE: C:\Users\HaiPiao\Desktop\附小实验\程序\project\HD7279\HD7279.C
(0001) /********************************************************
(0002) 
(0003) 电子技术实习基地
(0004) 
(0005) ************************************************************/
(0006) /************************ MEI *******************************
(0007) 	Module Name: HD7279.c
(0008) 	Module Date: 11/14/2013
(0009) 	Module Auth: 吕振
(0010) 	
(0011) 	Description: 7279键盘的使用
(0012) ************************* MEI *****************************/
(0013) /*------------------------Includes------------------------*/
(0014) #include "HD7279.h"
(0015) 
(0016) /***************外部调用函数*******************************/
(0017) 
(0018) /**********************************************************
(0019) 函数名：HD7279初始化函数	
(0020) 功  能：初始化HD7279（管脚配置、HD7279复位）
(0021) 输  入：无
(0022) 返  回：无
(0023) 备  注：使用先，选配置管脚的宏定义
(0024) *********************************************************/		
(0025) void init_7279(void)	
(0026) {
(0027) 	unsigned int tmr;
(0028) 	
(0029) 	DR7279 |= cs7279;		         //cs7279定义为输出
    005A6 9AD5      SBI	0x1A,5
(0030) 	DR7279 |= clk7279;		         //clk7279定义为输出
    005A7 9AD4      SBI	0x1A,4
(0031) 	DR7279 |= dat7279;		         //dat7279定义为输出
    005A8 9AD3      SBI	0x1A,3
(0032) 	DR7279 &= ~(key7279);		     //key7279定义为输入
    005A9 98D2      CBI	0x1A,2
(0033) 	
(0034) 	WR7279 |= cs7279;		         //cs7279初始化为1
    005AA 9ADD      SBI	0x1B,5
(0035)  	WR7279 |= clk7279;		         //clk7279初始化为1
    005AB 9ADC      SBI	0x1B,4
(0036)  	WR7279 |= dat7279;		         //dat7279初始化为1
    005AC 9ADB      SBI	0x1B,3
(0037)  	WR7279 |= key7279;		         //key7279初始化为有弱上拉 
    005AD 9ADA      SBI	0x1B,2
(0038)  	
(0039)  	for(tmr=0;tmr<0xf000;tmr++);	 //上电延时
    005AE 2744      CLR	R20
    005AF 2755      CLR	R21
    005B0 C002      RJMP	0x05B3
    005B1 5F4F      SUBI	R20,0xFF
    005B2 4F5F      SBCI	R21,0xFF
    005B3 3040      CPI	R20,0
    005B4 EFE0      LDI	R30,0xF0
    005B5 075E      CPC	R21,R30
    005B6 F3D0      BCS	0x05B1
(0040)  		
(0041) 	send_byte(CMD_RESET);		     //复位HD7279
    005B7 EA04      LDI	R16,0xA4
    005B8 D044      RCALL	_send_byte
    005B9 9159      LD	R21,Y+
    005BA 9149      LD	R20,Y+
    005BB 9508      RET
_write7279:
  dta                  --> R10
  cmd                  --> R12
    005BC 92AA      ST	-Y,R10
    005BD 92CA      ST	-Y,R12
    005BE 2EA2      MOV	R10,R18
    005BF 2EC0      MOV	R12,R16
(0042)  		 	 		
(0043) }  	 
(0044) 
(0045) /****************** **********************
(0046) 函数名：HD7279写入函数	
(0047) 功  能：对HD7279写数据
(0048) 输  入：cmd为指令数据;	dta为数据数据
(0049) 返  回：无
(0050) 备  注：HD7279的控制函数
(0051) ******************************************/
(0052) void write7279(unsigned char cmd,unsigned char dta)	//写入到HD7279
(0053) {	
(0054) 	send_byte(cmd);		//写指令
    005C0 2D0C      MOV	R16,R12
    005C1 D03B      RCALL	_send_byte
(0055) 	send_byte(dta);		//定数据
    005C2 2D0A      MOV	R16,R10
    005C3 D039      RCALL	_send_byte
    005C4 90C9      LD	R12,Y+
    005C5 90A9      LD	R10,Y+
    005C6 9508      RET
(0056) }
(0057) 
(0058) /****************** **********************
(0059) 函数名：HD7279读取函数	
(0060) 功  能：对HD7279读取原始键值
(0061) 输  入：无
(0062) 返  回：键盘原始键值
(0063) 备  注：HD7279的控制函数
(0064) ******************************************/
(0065) unsigned char read7279(void)
(0066) {
(0067) 	send_byte(0x15);	        //发送读取指令
_read7279:
    005C7 E105      LDI	R16,0x15
    005C8 D034      RCALL	_send_byte
(0068) 	return(receive_byte());	    //返回键值
    005C9 C04C      RJMP	_receive_byte
_get_key7279:
  KeyNum               --> R10
    005CA 92AA      ST	-Y,R10
(0069) 	
(0070) }
(0071) 
(0072) /****************** **********************
(0073) 函数名：HD7279按键等待接收函数	
(0074) 功  能：当完成一次按键，返回键值
(0075) 输  入：无
(0076) 返  回：键盘键值
(0077) 备  注：HD7279的控制函数
(0078) ******************************************/
(0079) unsigned char get_key7279(void)
(0080) {
(0081) 	unsigned char KeyNum;
(0082) 	while( (RD7279&key7279) );		//等待有键按下,无时为高电平
    005CB 99CA      SBIC	0x19,2
    005CC CFFE      RJMP	0x05CB
(0083) 	
(0084) 	delay10ms(1);				    //时延100ms
    005CD E001      LDI	R16,1
    005CE E010      LDI	R17,0
    005CF D017      RCALL	_delay10ms
(0085) 	
(0086) 	KeyNum=read7279();			    //读出键码	
    005D0 DFF6      RCALL	_read7279
(0087) 	
(0088) 	KeyNum=num_change7279(KeyNum);  //键码转为十进制
    005D1 D05B      RCALL	_num_change7279
    005D2 2EA0      MOV	R10,R16
(0089) 	
(0090) 	delay10ms(1);				    //时延100ms
    005D3 E001      LDI	R16,1
    005D4 E010      LDI	R17,0
    005D5 D011      RCALL	_delay10ms
(0091) 	
(0092) 	while( !(RD7279&key7279) );		//等待按键松开
    005D6 9BCA      SBIS	0x19,2
    005D7 CFFE      RJMP	0x05D6
(0093) 	
(0094) 	return KeyNum;				    //返回键值
    005D8 2D0A      MOV	R16,R10
    005D9 90A9      LD	R10,Y+
    005DA 9508      RET
(0095) }
(0096) 
(0097) /******************************内部函数************************************/
(0098) void long_delay(void)               //长时延函数
(0099) {
(0100) 	unsigned char i;
(0101) 	for(i=0;i<80;i++);
_long_delay:
  i                    --> R16
    005DB 2700      CLR	R16
    005DC C001      RJMP	0x05DE
    005DD 9503      INC	R16
    005DE 3500      CPI	R16,0x50
    005DF F3E8      BCS	0x05DD
    005E0 9508      RET
(0102) }	
(0103) 
(0104) void short_delay(void)            //短时延函数					
(0105) 
(0106) {
(0107) 	unsigned char i;
(0108) 	for(i=0;i<46;i++);
_short_delay:
  i                    --> R16
    005E1 2700      CLR	R16
    005E2 C001      RJMP	0x05E4
    005E3 9503      INC	R16
    005E4 320E      CPI	R16,0x2E
    005E5 F3E8      BCS	0x05E3
    005E6 9508      RET
_delay10ms:
  i                    --> R10
  j                    --> R20
  k                    --> R22
  count                --> R16
    005E7 940E 0BE4 CALL	push_xgsetF00C
(0109) }
(0110) 				
(0111) void delay10ms(unsigned int count)//10ms时延函数
(0112) {
(0113) 	unsigned char i,j,k;
(0114)  	for (i=0;i<count;i++)
    005E9 24AA      CLR	R10
    005EA C00B      RJMP	0x05F6
(0115)       		for(j=0;j<100;j++)
    005EB 2744      CLR	R20
    005EC C006      RJMP	0x05F3
(0116)       			for(k=0;k<100;k++);
    005ED 2766      CLR	R22
    005EE C001      RJMP	0x05F0
    005EF 9563      INC	R22
    005F0 3664      CPI	R22,0x64
    005F1 F3E8      BCS	0x05EF
    005F2 9543      INC	R20
    005F3 3644      CPI	R20,0x64
    005F4 F3C0      BCS	0x05ED
    005F5 94A3      INC	R10
    005F6 2C2A      MOV	R2,R10
    005F7 2433      CLR	R3
    005F8 1620      CP	R2,R16
    005F9 0631      CPC	R3,R17
    005FA F380      BCS	0x05EB
    005FB 940C 0BEB JMP	pop_xgsetF00C
_send_byte:
  i                    --> R20
  out_byte             --> R10
    005FD 92AA      ST	-Y,R10
    005FE 934A      ST	-Y,R20
    005FF 2EA0      MOV	R10,R16
(0117) }	
(0118) 	
(0119) /****************** **********************
(0120) 函数名：HD7279字节发送函数	
(0121) 功  能：HD7279发送一个字节
(0122) 输  入：一个字节
(0123) 返  回：无
(0124) 备  注：HD7279硬件函数
(0125) ******************************************/
(0126) void send_byte(unsigned char out_byte)
(0127) {	
(0128) 	unsigned char i;
(0129) 	
(0130) 	WR7279&=~clk7279;		    //clk7279=0;
    00600 98DC      CBI	0x1B,4
(0131) 	WR7279&=~cs7279;		    //cs7279=0
    00601 98DD      CBI	0x1B,5
(0132) 	long_delay();
    00602 DFD8      RCALL	_long_delay
(0133) 	
(0134) 	for(i=0;i<8;i++)
    00603 2744      CLR	R20
    00604 C00B      RJMP	0x0610
(0135) 	{
(0136) 		if(out_byte&0x80)
    00605 FEA7      SBRS	R10,7
    00606 C002      RJMP	0x0609
(0137) 		{
(0138) 			WR7279|=dat7279;	//dat7279=1;
    00607 9ADB      SBI	0x1B,3
(0139) 		 }
    00608 C001      RJMP	0x060A
(0140) 		 else
(0141) 		 {
(0142) 		 	WR7279&=~dat7279;	//dat7279=0;
    00609 98DB      CBI	0x1B,3
(0143) 		 }
(0144) 		 WR7279|=clk7279;		//clk7279=1;
    0060A 9ADC      SBI	0x1B,4
(0145) 		 short_delay();
    0060B DFD5      RCALL	_short_delay
(0146) 		 WR7279&=~clk7279;		//clk7279=0;
    0060C 98DC      CBI	0x1B,4
(0147) 		 short_delay();
    0060D DFD3      RCALL	_short_delay
(0148) 		 out_byte=out_byte<<1;
    0060E 0CAA      LSL	R10
    0060F 9543      INC	R20
    00610 3048      CPI	R20,0x8
    00611 F398      BCS	0x0605
(0149) 	 }
(0150) 	 WR7279|=dat7279;			//dat7279=1; 	 
    00612 9ADB      SBI	0x1B,3
    00613 9149      LD	R20,Y+
    00614 90A9      LD	R10,Y+
    00615 9508      RET
_receive_byte:
  i                    --> R22
  in_byte              --> R20
    00616 934A      ST	-Y,R20
    00617 936A      ST	-Y,R22
(0151) }
(0152) 	
(0153) /****************** **********************
(0154) 函数名：HD7279字节接收函数	
(0155) 功  能：从HD7279接收一个字节
(0156) 输  入：无
(0157) 返  回：一个字节
(0158) 备  注：HD7279硬件函数
(0159) ******************************************/
(0160) unsigned char receive_byte(void)
(0161) {
(0162) 	unsigned char i,in_byte;
(0163) 	
(0164) 	WR7279|=clk7279;		    //clk7279=1;
    00618 9ADC      SBI	0x1B,4
(0165) 	
(0166) 	DR7279&=~dat7279;			//改dat7279为输入
    00619 98D3      CBI	0x1A,3
(0167) 	
(0168) 	long_delay();
    0061A DFC0      RCALL	_long_delay
(0169) 	
(0170) 	for(i=0;i<8;i++)
    0061B 2766      CLR	R22
    0061C C009      RJMP	0x0626
(0171) 	{	
(0172) 		WR7279|=clk7279;		//clk7279=1;
    0061D 9ADC      SBI	0x1B,4
(0173) 		short_delay();
    0061E DFC2      RCALL	_short_delay
(0174) 		in_byte=in_byte<<1;
    0061F 0F44      LSL	R20
(0175) 		if(RD7279&dat7279)
    00620 9BCB      SBIS	0x19,3
    00621 C001      RJMP	0x0623
(0176) 		{
(0177) 			in_byte=in_byte|0x01;
    00622 6041      ORI	R20,1
(0178) 		}
(0179) 		WR7279&=~clk7279;		//clk7279=0;
    00623 98DC      CBI	0x1B,4
(0180) 		short_delay();
    00624 DFBC      RCALL	_short_delay
    00625 9563      INC	R22
    00626 3068      CPI	R22,0x8
    00627 F3A8      BCS	0x061D
(0181) 	
(0182) 	}
(0183) 	DR7279|=dat7279;			//dat7279还原为输出口
    00628 9AD3      SBI	0x1A,3
(0184) 	return(in_byte);
    00629 2F04      MOV	R16,R20
    0062A 9169      LD	R22,Y+
    0062B 9149      LD	R20,Y+
    0062C 9508      RET
_num_change7279:
  X                    --> R16
    0062D 934A      ST	-Y,R20
    0062E 935A      ST	-Y,R21
(0185) }
(0186) 
(0187) /****************** **********************
(0188) 函数名：HD7279按键等待接收函数	
(0189) 功  能：当完成一次按键，返回键值
(0190) 输  入：无
(0191) 返  回：键盘键值
(0192) 备  注：HD7279的控制函数
(0193) ******************************************/
(0194) unsigned char  num_change7279 (unsigned char X)
(0195)  {
(0196)    	switch (X)
    0062F 2F40      MOV	R20,R16
    00630 2755      CLR	R21
    00631 3040      CPI	R20,0
    00632 E0E0      LDI	R30,0
    00633 075E      CPC	R21,R30
    00634 F40C      BGE	0x0636
    00635 C031      RJMP	0x0667
    00636 E18B      LDI	R24,0x1B
    00637 E090      LDI	R25,0
    00638 1784      CP	R24,R20
    00639 0795      CPC	R25,R21
    0063A F40C      BGE	0x063C
    0063B C02B      RJMP	0x0667
    0063C E584      LDI	R24,0x54
    0063D E090      LDI	R25,0
    0063E 01FA      MOVW	R30,R20
    0063F 0FEE      LSL	R30
    00640 1FFF      ROL	R31
    00641 0FE8      ADD	R30,R24
    00642 1FF9      ADC	R31,R25
    00643 9025      LPM	R2,Z+
    00644 9034      LPM	R3,Z
    00645 01F1      MOVW	R30,R2
    00646 9409      IJMP
(0197) 	{
(0198) 		case  ONE 	: return 0X01;
    00647 E001      LDI	R16,1
    00648 C01F      RJMP	0x0668
(0199) 		case  TWO 	: return 0X02;
    00649 E002      LDI	R16,2
    0064A C01D      RJMP	0x0668
(0200) 		case  THREE 	: return 0X03;
    0064B E003      LDI	R16,3
    0064C C01B      RJMP	0x0668
(0201) 		case  FOUR 	: return 0X04;
    0064D E004      LDI	R16,4
    0064E C019      RJMP	0x0668
(0202) 		case  FIVE 	: return 0X05;
    0064F E005      LDI	R16,5
    00650 C017      RJMP	0x0668
(0203) 		case  SIX  	: return 0X06;
    00651 E006      LDI	R16,6
    00652 C015      RJMP	0x0668
(0204) 		case  SEVEN 	: return 0X07;
    00653 E007      LDI	R16,7
    00654 C013      RJMP	0x0668
(0205) 		case  EIGHT 	: return 0X08;
    00655 E008      LDI	R16,0x8
    00656 C011      RJMP	0x0668
(0206) 		case  NINE 	: return 0X09;
    00657 E009      LDI	R16,0x9
    00658 C00F      RJMP	0x0668
(0207) 		case  ZERO 	: return 0X00;
    00659 2700      CLR	R16
    0065A C00D      RJMP	0x0668
(0208) 		case  AAAA  	: return 0x0A;
    0065B E00A      LDI	R16,0xA
    0065C C00B      RJMP	0x0668
(0209) 		case  BBBB 	: return 0x0B;
    0065D E00B      LDI	R16,0xB
    0065E C009      RJMP	0x0668
(0210) 		case  CCCC 	: return 0x0C;
    0065F E00C      LDI	R16,0xC
    00660 C007      RJMP	0x0668
(0211) 		case  DDDD 	: return 0x0D;
    00661 E00D      LDI	R16,0xD
    00662 C005      RJMP	0x0668
(0212) 		case  EEEE 	: return 0x0E;
    00663 E00E      LDI	R16,0xE
    00664 C003      RJMP	0x0668
(0213) 		case  FFFF 	: return 0x0F;
    00665 E00F      LDI	R16,0xF
    00666 C001      RJMP	0x0668
(0214) 		default 	: return 0xFF;
    00667 EF0F      LDI	R16,0xFF
    00668 9159      LD	R21,Y+
    00669 9149      LD	R20,Y+
    0066A 9508      RET
_test_7279:
  key7279_number       --> R20
  wait_cnter           --> Y,+12
  tmr                  --> Y,+8
  k                    --> Y,+4
  j                    --> Y,+0
    0066B 934A      ST	-Y,R20
    0066C 9760      SBIW	R28,0x10
(0215) 	}
(0216) }
(0217) 
(0218) 
(0219) 		
(0220) 
(0221) 
(0222) /****************** HD7279测试函数*************************/
(0223) void test_7279(void)
(0224) {
(0225) 	unsigned long wait_cnter;
(0226) 	unsigned long tmr,j,k;
(0227) 	unsigned char key7279_number;
(0228) 	init_7279();
    0066D DF36      RCALL	_init_7279
    0066E C1E1      RJMP	0x0850
(0229) 	while(1)
(0230) 	{
(0231) 		for(tmr=0;tmr<0xf000;tmr++);	//上电延时
    0066F E080      LDI	R24,0
    00670 8788      STD	Y+8,R24
    00671 8789      STD	Y+9,R24
    00672 878A      STD	Y+10,R24
    00673 878B      STD	Y+11,R24
    00674 C010      RJMP	0x0685
    00675 E081      LDI	R24,1
    00676 E090      LDI	R25,0
    00677 E0A0      LDI	R26,0
    00678 E0B0      LDI	R27,0
    00679 8428      LDD	R2,Y+8
    0067A 8439      LDD	R3,Y+9
    0067B 844A      LDD	R4,Y+10
    0067C 845B      LDD	R5,Y+11
    0067D 0E28      ADD	R2,R24
    0067E 1E39      ADC	R3,R25
    0067F 1E4A      ADC	R4,R26
    00680 1E5B      ADC	R5,R27
    00681 8628      STD	Y+8,R2
    00682 8639      STD	Y+9,R3
    00683 864A      STD	Y+10,R4
    00684 865B      STD	Y+11,R5
    00685 E080      LDI	R24,0
    00686 EF90      LDI	R25,0xF0
    00687 E0A0      LDI	R26,0
    00688 E0B0      LDI	R27,0
    00689 8428      LDD	R2,Y+8
    0068A 8439      LDD	R3,Y+9
    0068B 844A      LDD	R4,Y+10
    0068C 845B      LDD	R5,Y+11
    0068D 1628      CP	R2,R24
    0068E 0639      CPC	R3,R25
    0068F 064A      CPC	R4,R26
    00690 065B      CPC	R5,R27
    00691 F318      BCS	0x0675
(0232) 		send_byte(CMD_RESET);		    //复位HD7279
    00692 EA04      LDI	R16,0xA4
    00693 DF69      RCALL	_send_byte
(0233) 
(0234) 		//测试指令演示
(0235) 
(0236) 		send_byte(CMD_TEST);
    00694 EB0F      LDI	R16,0xBF
    00695 DF67      RCALL	_send_byte
(0237) 		for(j=0;j<3;j++)		        //延时约3秒
    00696 E080      LDI	R24,0
    00697 8388      ST	Y,R24
    00698 8389      STD	Y+1,R24
    00699 838A      STD	Y+2,R24
    0069A 838B      STD	Y+3,R24
    0069B C013      RJMP	0x06AF
(0238) 		{	
(0239) 			delay10ms(100);
    0069C E604      LDI	R16,0x64
    0069D E010      LDI	R17,0
    0069E DF48      RCALL	_delay10ms
    0069F E081      LDI	R24,1
    006A0 E090      LDI	R25,0
    006A1 E0A0      LDI	R26,0
    006A2 E0B0      LDI	R27,0
    006A3 8028      LD	R2,Y
    006A4 8039      LDD	R3,Y+1
    006A5 804A      LDD	R4,Y+2
    006A6 805B      LDD	R5,Y+3
    006A7 0E28      ADD	R2,R24
    006A8 1E39      ADC	R3,R25
    006A9 1E4A      ADC	R4,R26
    006AA 1E5B      ADC	R5,R27
    006AB 8228      ST	Y,R2
    006AC 8239      STD	Y+1,R3
    006AD 824A      STD	Y+2,R4
    006AE 825B      STD	Y+3,R5
    006AF E083      LDI	R24,3
    006B0 E090      LDI	R25,0
    006B1 E0A0      LDI	R26,0
    006B2 E0B0      LDI	R27,0
    006B3 8028      LD	R2,Y
    006B4 8039      LDD	R3,Y+1
    006B5 804A      LDD	R4,Y+2
    006B6 805B      LDD	R5,Y+3
    006B7 1628      CP	R2,R24
    006B8 0639      CPC	R3,R25
    006B9 064A      CPC	R4,R26
    006BA 065B      CPC	R5,R27
    006BB F300      BCS	0x069C
(0240) 		}
(0241) 		send_byte(CMD_RESET);		    //清除显示
    006BC EA04      LDI	R16,0xA4
    006BD DF3F      RCALL	_send_byte
(0242) 		
(0243) 	
(0244) 		{	
(0245) 		 write7279(DECODE0+0,0x80);
    006BE E820      LDI	R18,0x80
    006BF E800      LDI	R16,0x80
    006C0 DEFB      RCALL	_write7279
(0246) 		 write7279(DECODE0+1,0x81);
    006C1 E821      LDI	R18,0x81
    006C2 E801      LDI	R16,0x81
    006C3 DEF8      RCALL	_write7279
(0247) 		 write7279(DECODE0+2,0x82);
    006C4 E822      LDI	R18,0x82
    006C5 E802      LDI	R16,0x82
    006C6 DEF5      RCALL	_write7279
(0248) 		 write7279(DECODE0+3,0x83);
    006C7 E823      LDI	R18,0x83
    006C8 E803      LDI	R16,0x83
    006C9 DEF2      RCALL	_write7279
(0249) 		 write7279(DECODE0+4,0x84);
    006CA E824      LDI	R18,0x84
    006CB E804      LDI	R16,0x84
    006CC DEEF      RCALL	_write7279
(0250) 		 write7279(DECODE0+5,0x85);
    006CD E825      LDI	R18,0x85
    006CE E805      LDI	R16,0x85
    006CF DEEC      RCALL	_write7279
(0251) 		 write7279(DECODE0+6,0x86);
    006D0 E826      LDI	R18,0x86
    006D1 E806      LDI	R16,0x86
    006D2 DEE9      RCALL	_write7279
(0252) 		 write7279(DECODE0+7,0x87);
    006D3 E827      LDI	R18,0x87
    006D4 E807      LDI	R16,0x87
    006D5 DEE6      RCALL	_write7279
(0253) 		 }
(0254) 		 
(0255) 		delay10ms(200);
    006D6 EC08      LDI	R16,0xC8
    006D7 E010      LDI	R17,0
    006D8 DF0E      RCALL	_delay10ms
(0256) 
(0257) 		//闪烁指令及键盘接口测试，
(0258) 		//将用户按键的键码显示出来，
(0259) 		//如果10秒内无按键或按S0键即进入下一步演示
(0260) 		wait_cnter=0;
    006D9 E080      LDI	R24,0
    006DA 878C      STD	Y+12,R24
    006DB 878D      STD	Y+13,R24
    006DC 878E      STD	Y+14,R24
    006DD 878F      STD	Y+15,R24
(0261) 		key7279_number=0xff;
    006DE EF4F      LDI	R20,0xFF
(0262) 		write7279(BLINKCTL,0xfc);			//第1?2两位设为闪烁显示 1111，1100
    006DF EF2C      LDI	R18,0xFC
    006E0 E808      LDI	R16,0x88
    006E1 DEDA      RCALL	_write7279
(0263) 		write7279(UNDECODE,0x08);           //0x08 is '_'
    006E2 E028      LDI	R18,0x8
    006E3 E900      LDI	R16,0x90
    006E4 DED7      RCALL	_write7279
(0264) 		write7279(UNDECODE+1,0x08);			//在第1?2位显示下划线'_'
    006E5 E028      LDI	R18,0x8
    006E6 E901      LDI	R16,0x91
    006E7 DED4      RCALL	_write7279
(0265) 		do
(0266) 		{
(0267) 			if(!(RD7279&key7279))			//如果有键按下
    006E8 99CA      SBIC	0x19,2
    006E9 C01B      RJMP	0x0705
(0268) 			{   
(0269) 			 write7279(DECODE0+7,0x88);
    006EA E828      LDI	R18,0x88
    006EB E807      LDI	R16,0x87
    006EC DECF      RCALL	_write7279
(0270) 			 key7279_number=read7279();     //读出键码
    006ED DED9      RCALL	_read7279
    006EE 2F40      MOV	R20,R16
(0271) 			 write7279(BLINKCTL,0xff);
    006EF EF2F      LDI	R18,0xFF
    006F0 E808      LDI	R16,0x88
    006F1 DECA      RCALL	_write7279
(0272) 			 write7279(DECODE1+1,key7279_number/16);	//在第2 位显示键码高8位
    006F2 2F24      MOV	R18,R20
    006F3 9522      SWAP	R18
    006F4 702F      ANDI	R18,0xF
    006F5 EC09      LDI	R16,0xC9
    006F6 DEC5      RCALL	_write7279
(0273) 			 write7279(DECODE1,key7279_number&0x0f);	//在第1位显示键码低8位
    006F7 2F24      MOV	R18,R20
    006F8 702F      ANDI	R18,0xF
    006F9 EC08      LDI	R16,0xC8
    006FA DEC1      RCALL	_write7279
(0274) 			 while(!(RD7279&key7279));			        //等待按键放开
    006FB 9BCA      SBIS	0x19,2
    006FC CFFE      RJMP	0x06FB
(0275) 			 wait_cnter=0;
    006FD E080      LDI	R24,0
    006FE 878C      STD	Y+12,R24
    006FF 878D      STD	Y+13,R24
    00700 878E      STD	Y+14,R24
    00701 878F      STD	Y+15,R24
(0276) 			 delay10ms(10); 
    00702 E00A      LDI	R16,0xA
    00703 E010      LDI	R17,0
    00704 DEE2      RCALL	_delay10ms
(0277) 			}	
(0278) 		}
(0279) 		while(wait_cnter<1000);	
    00705 EE88      LDI	R24,0xE8
    00706 E093      LDI	R25,3
    00707 E0A0      LDI	R26,0
    00708 E0B0      LDI	R27,0
    00709 842C      LDD	R2,Y+12
    0070A 843D      LDD	R3,Y+13
    0070B 844E      LDD	R4,Y+14
    0070C 845F      LDD	R5,Y+15
    0070D 1628      CP	R2,R24
    0070E 0639      CPC	R3,R25
    0070F 064A      CPC	R4,R26
    00710 065B      CPC	R5,R27
    00711 F2B0      BCS	0x06E8
(0280) 		
(0281) 		//如果按键为'0'和超时则进入下一步演示
(0282) 		write7279(BLINKCTL,0xff);			//清除闪烁设置 无位显示闪烁1111,1111
    00712 EF2F      LDI	R18,0xFF
    00713 E808      LDI	R16,0x88
    00714 DEA7      RCALL	_write7279
(0283) 		send_byte(CMD_RESET);				//清除显示
    00715 EA04      LDI	R16,0xA4
    00716 DEE6      RCALL	_send_byte
(0284) 	
(0285) 		//下载数据但不译码指令测试
(0286) 		write7279(UNDECODE+7,0x49);		//在第8位按不译码方式显示一个字符‘三’。
    00717 E429      LDI	R18,0x49
    00718 E907      LDI	R16,0x97
    00719 DEA2      RCALL	_write7279
(0287) 		delay10ms(80);
    0071A E500      LDI	R16,0x50
    0071B E010      LDI	R17,0
    0071C DECA      RCALL	_delay10ms
(0288) 	
(0289) 		//循环左右移测试，‘三’字向右移3次，再向左移3次。
(0290) 		for(j=0;j<23;j++)
    0071D E080      LDI	R24,0
    0071E 8388      ST	Y,R24
    0071F 8389      STD	Y+1,R24
    00720 838A      STD	Y+2,R24
    00721 838B      STD	Y+3,R24
    00722 C015      RJMP	0x0738
(0291) 		{
(0292) 			send_byte(RTR_CYCLE);			//循环右移23次
    00723 EA02      LDI	R16,0xA2
    00724 DED8      RCALL	_send_byte
(0293) 			delay10ms(12);
    00725 E00C      LDI	R16,0xC
    00726 E010      LDI	R17,0
    00727 DEBF      RCALL	_delay10ms
    00728 E081      LDI	R24,1
    00729 E090      LDI	R25,0
    0072A E0A0      LDI	R26,0
    0072B E0B0      LDI	R27,0
    0072C 8028      LD	R2,Y
    0072D 8039      LDD	R3,Y+1
    0072E 804A      LDD	R4,Y+2
    0072F 805B      LDD	R5,Y+3
    00730 0E28      ADD	R2,R24
    00731 1E39      ADC	R3,R25
    00732 1E4A      ADC	R4,R26
    00733 1E5B      ADC	R5,R27
    00734 8228      ST	Y,R2
    00735 8239      STD	Y+1,R3
    00736 824A      STD	Y+2,R4
    00737 825B      STD	Y+3,R5
    00738 E187      LDI	R24,0x17
    00739 E090      LDI	R25,0
    0073A E0A0      LDI	R26,0
    0073B E0B0      LDI	R27,0
    0073C 8028      LD	R2,Y
    0073D 8039      LDD	R3,Y+1
    0073E 804A      LDD	R4,Y+2
    0073F 805B      LDD	R5,Y+3
    00740 1628      CP	R2,R24
    00741 0639      CPC	R3,R25
    00742 064A      CPC	R4,R26
    00743 065B      CPC	R5,R27
    00744 F2F0      BCS	0x0723
(0294) 		}
(0295) 		
(0296) 		for(j=0;j<23;j++)
    00745 E080      LDI	R24,0
    00746 8388      ST	Y,R24
    00747 8389      STD	Y+1,R24
    00748 838A      STD	Y+2,R24
    00749 838B      STD	Y+3,R24
    0074A C015      RJMP	0x0760
(0297) 		{
(0298) 			send_byte(RTL_CYCLE);			//循环左移23次
    0074B EA03      LDI	R16,0xA3
    0074C DEB0      RCALL	_send_byte
(0299) 			delay10ms(12);
    0074D E00C      LDI	R16,0xC
    0074E E010      LDI	R17,0
    0074F DE97      RCALL	_delay10ms
    00750 E081      LDI	R24,1
    00751 E090      LDI	R25,0
    00752 E0A0      LDI	R26,0
    00753 E0B0      LDI	R27,0
    00754 8028      LD	R2,Y
    00755 8039      LDD	R3,Y+1
    00756 804A      LDD	R4,Y+2
    00757 805B      LDD	R5,Y+3
    00758 0E28      ADD	R2,R24
    00759 1E39      ADC	R3,R25
    0075A 1E4A      ADC	R4,R26
    0075B 1E5B      ADC	R5,R27
    0075C 8228      ST	Y,R2
    0075D 8239      STD	Y+1,R3
    0075E 824A      STD	Y+2,R4
    0075F 825B      STD	Y+3,R5
    00760 E187      LDI	R24,0x17
    00761 E090      LDI	R25,0
    00762 E0A0      LDI	R26,0
    00763 E0B0      LDI	R27,0
    00764 8028      LD	R2,Y
    00765 8039      LDD	R3,Y+1
    00766 804A      LDD	R4,Y+2
    00767 805B      LDD	R5,Y+3
    00768 1628      CP	R2,R24
    00769 0639      CPC	R3,R25
    0076A 064A      CPC	R4,R26
    0076B 065B      CPC	R5,R27
    0076C F2F0      BCS	0x074B
(0300) 		}
(0301) 	
(0302) 		//译码方式0及左移指令测试
(0303) 		for(j=0;j<16;j++)
    0076D E080      LDI	R24,0
    0076E 8388      ST	Y,R24
    0076F 8389      STD	Y+1,R24
    00770 838A      STD	Y+2,R24
    00771 838B      STD	Y+3,R24
    00772 C01C      RJMP	0x078F
(0304) 		{
(0305) 			send_byte(RTL_UNCYL);			//不循环左移指令
    00773 EA01      LDI	R16,0xA1
    00774 DE88      RCALL	_send_byte
(0306) 			write7279(DECODE0,j);			//译码方式0，显示在第1位
    00775 8028      LD	R2,Y
    00776 8039      LDD	R3,Y+1
    00777 804A      LDD	R4,Y+2
    00778 805B      LDD	R5,Y+3
    00779 2D22      MOV	R18,R2
    0077A E800      LDI	R16,0x80
    0077B DE40      RCALL	_write7279
(0307) 			delay10ms(50);
    0077C E302      LDI	R16,0x32
    0077D E010      LDI	R17,0
    0077E DE68      RCALL	_delay10ms
    0077F E081      LDI	R24,1
    00780 E090      LDI	R25,0
    00781 E0A0      LDI	R26,0
    00782 E0B0      LDI	R27,0
    00783 8028      LD	R2,Y
    00784 8039      LDD	R3,Y+1
    00785 804A      LDD	R4,Y+2
    00786 805B      LDD	R5,Y+3
    00787 0E28      ADD	R2,R24
    00788 1E39      ADC	R3,R25
    00789 1E4A      ADC	R4,R26
    0078A 1E5B      ADC	R5,R27
    0078B 8228      ST	Y,R2
    0078C 8239      STD	Y+1,R3
    0078D 824A      STD	Y+2,R4
    0078E 825B      STD	Y+3,R5
    0078F E180      LDI	R24,0x10
    00790 E090      LDI	R25,0
    00791 E0A0      LDI	R26,0
    00792 E0B0      LDI	R27,0
    00793 8028      LD	R2,Y
    00794 8039      LDD	R3,Y+1
    00795 804A      LDD	R4,Y+2
    00796 805B      LDD	R5,Y+3
    00797 1628      CP	R2,R24
    00798 0639      CPC	R3,R25
    00799 064A      CPC	R4,R26
    0079A 065B      CPC	R5,R27
    0079B F2B8      BCS	0x0773
(0308) 		}
(0309) 			delay10ms(150);
    0079C E906      LDI	R16,0x96
    0079D E010      LDI	R17,0
    0079E DE48      RCALL	_delay10ms
(0310) 			send_byte(CMD_RESET);
    0079F EA04      LDI	R16,0xA4
    007A0 DE5C      RCALL	_send_byte
(0311) 	
(0312) 		//译码方式1及右移指令测试
(0313) 		for(j=0;j<16;j++)
    007A1 E080      LDI	R24,0
    007A2 8388      ST	Y,R24
    007A3 8389      STD	Y+1,R24
    007A4 838A      STD	Y+2,R24
    007A5 838B      STD	Y+3,R24
    007A6 C01C      RJMP	0x07C3
(0314) 		{
(0315) 			send_byte(RTR_UNCYL);			//不循环左移指令
    007A7 EA00      LDI	R16,0xA0
    007A8 DE54      RCALL	_send_byte
(0316) 			write7279(DECODE1+7,j);			//译码方式1，显示在第8位
    007A9 8028      LD	R2,Y
    007AA 8039      LDD	R3,Y+1
    007AB 804A      LDD	R4,Y+2
    007AC 805B      LDD	R5,Y+3
    007AD 2D22      MOV	R18,R2
    007AE EC0F      LDI	R16,0xCF
    007AF DE0C      RCALL	_write7279
(0317) 			delay10ms(50);
    007B0 E302      LDI	R16,0x32
    007B1 E010      LDI	R17,0
    007B2 DE34      RCALL	_delay10ms
    007B3 E081      LDI	R24,1
    007B4 E090      LDI	R25,0
    007B5 E0A0      LDI	R26,0
    007B6 E0B0      LDI	R27,0
    007B7 8028      LD	R2,Y
    007B8 8039      LDD	R3,Y+1
    007B9 804A      LDD	R4,Y+2
    007BA 805B      LDD	R5,Y+3
    007BB 0E28      ADD	R2,R24
    007BC 1E39      ADC	R3,R25
    007BD 1E4A      ADC	R4,R26
    007BE 1E5B      ADC	R5,R27
    007BF 8228      ST	Y,R2
    007C0 8239      STD	Y+1,R3
    007C1 824A      STD	Y+2,R4
    007C2 825B      STD	Y+3,R5
    007C3 E180      LDI	R24,0x10
    007C4 E090      LDI	R25,0
    007C5 E0A0      LDI	R26,0
    007C6 E0B0      LDI	R27,0
    007C7 8028      LD	R2,Y
    007C8 8039      LDD	R3,Y+1
    007C9 804A      LDD	R4,Y+2
    007CA 805B      LDD	R5,Y+3
    007CB 1628      CP	R2,R24
    007CC 0639      CPC	R3,R25
    007CD 064A      CPC	R4,R26
    007CE 065B      CPC	R5,R27
    007CF F2B8      BCS	0x07A7
(0318) 		}
(0319) 		delay10ms(150);
    007D0 E906      LDI	R16,0x96
    007D1 E010      LDI	R17,0
    007D2 DE14      RCALL	_delay10ms
(0320) 	
(0321) 		//消隐指令测试
(0322) 	
(0323) 		for(j=0;j<6;j++)
    007D3 E080      LDI	R24,0
    007D4 8388      ST	Y,R24
    007D5 8389      STD	Y+1,R24
    007D6 838A      STD	Y+2,R24
    007D7 838B      STD	Y+3,R24
    007D8 C026      RJMP	0x07FF
(0324) 		{
(0325) 			k=k>>1;
    007D9 802C      LDD	R2,Y+4
    007DA 803D      LDD	R3,Y+5
    007DB 804E      LDD	R4,Y+6
    007DC 805F      LDD	R5,Y+7
    007DD 9456      LSR	R5
    007DE 9447      ROR	R4
    007DF 9437      ROR	R3
    007E0 9427      ROR	R2
    007E1 822C      STD	Y+4,R2
    007E2 823D      STD	Y+5,R3
    007E3 824E      STD	Y+6,R4
    007E4 825F      STD	Y+7,R5
(0326) 			write7279(ACTCTL,k);			//每隔一秒钟增加一个消隐位
    007E5 802C      LDD	R2,Y+4
    007E6 803D      LDD	R3,Y+5
    007E7 804E      LDD	R4,Y+6
    007E8 805F      LDD	R5,Y+7
    007E9 2D22      MOV	R18,R2
    007EA E908      LDI	R16,0x98
    007EB DDD0      RCALL	_write7279
(0327) 			delay10ms(100);
    007EC E604      LDI	R16,0x64
    007ED E010      LDI	R17,0
    007EE DDF8      RCALL	_delay10ms
    007EF E081      LDI	R24,1
    007F0 E090      LDI	R25,0
    007F1 E0A0      LDI	R26,0
    007F2 E0B0      LDI	R27,0
    007F3 8028      LD	R2,Y
    007F4 8039      LDD	R3,Y+1
    007F5 804A      LDD	R4,Y+2
    007F6 805B      LDD	R5,Y+3
    007F7 0E28      ADD	R2,R24
    007F8 1E39      ADC	R3,R25
    007F9 1E4A      ADC	R4,R26
    007FA 1E5B      ADC	R5,R27
    007FB 8228      ST	Y,R2
    007FC 8239      STD	Y+1,R3
    007FD 824A      STD	Y+2,R4
    007FE 825B      STD	Y+3,R5
    007FF E086      LDI	R24,6
    00800 E090      LDI	R25,0
    00801 E0A0      LDI	R26,0
    00802 E0B0      LDI	R27,0
    00803 8028      LD	R2,Y
    00804 8039      LDD	R3,Y+1
    00805 804A      LDD	R4,Y+2
    00806 805B      LDD	R5,Y+3
    00807 1628      CP	R2,R24
    00808 0639      CPC	R3,R25
    00809 064A      CPC	R4,R26
    0080A 065B      CPC	R5,R27
    0080B F268      BCS	0x07D9
(0328) 		}
(0329) 		write7279(ACTCTL,0xff);				//恢复8位显示
    0080C EF2F      LDI	R18,0xFF
    0080D E908      LDI	R16,0x98
    0080E DDAD      RCALL	_write7279
(0330) 		delay10ms(100);
    0080F E604      LDI	R16,0x64
    00810 E010      LDI	R17,0
    00811 DDD5      RCALL	_delay10ms
(0331) 		send_byte(CMD_RESET);				//清除显示
    00812 EA04      LDI	R16,0xA4
    00813 DDE9      RCALL	_send_byte
(0332) 	
(0333) 		//段点亮指令和段关闭指令
(0334) 		for(j=0;j<64;j++)
    00814 E080      LDI	R24,0
    00815 8388      ST	Y,R24
    00816 8389      STD	Y+1,R24
    00817 838A      STD	Y+2,R24
    00818 838B      STD	Y+3,R24
    00819 C029      RJMP	0x0843
(0335) 		{
(0336) 			write7279(SEGON,j);			//将64个显示段逐个点亮
    0081A 8028      LD	R2,Y
    0081B 8039      LDD	R3,Y+1
    0081C 804A      LDD	R4,Y+2
    0081D 805B      LDD	R5,Y+3
    0081E 2D22      MOV	R18,R2
    0081F EE00      LDI	R16,0xE0
    00820 DD9B      RCALL	_write7279
(0337) 			write7279(SEGOFF,j-1);			//同时将前一个显示段关闭
    00821 E081      LDI	R24,1
    00822 E090      LDI	R25,0
    00823 E0A0      LDI	R26,0
    00824 E0B0      LDI	R27,0
    00825 8028      LD	R2,Y
    00826 8039      LDD	R3,Y+1
    00827 804A      LDD	R4,Y+2
    00828 805B      LDD	R5,Y+3
    00829 1A28      SUB	R2,R24
    0082A 0A39      SBC	R3,R25
    0082B 0A4A      SBC	R4,R26
    0082C 0A5B      SBC	R5,R27
    0082D 2D22      MOV	R18,R2
    0082E EC00      LDI	R16,0xC0
    0082F DD8C      RCALL	_write7279
(0338) 			delay10ms(20);
    00830 E104      LDI	R16,0x14
    00831 E010      LDI	R17,0
    00832 DDB4      RCALL	_delay10ms
    00833 E081      LDI	R24,1
    00834 E090      LDI	R25,0
    00835 E0A0      LDI	R26,0
    00836 E0B0      LDI	R27,0
    00837 8028      LD	R2,Y
    00838 8039      LDD	R3,Y+1
    00839 804A      LDD	R4,Y+2
    0083A 805B      LDD	R5,Y+3
    0083B 0E28      ADD	R2,R24
    0083C 1E39      ADC	R3,R25
    0083D 1E4A      ADC	R4,R26
    0083E 1E5B      ADC	R5,R27
    0083F 8228      ST	Y,R2
    00840 8239      STD	Y+1,R3
    00841 824A      STD	Y+2,R4
    00842 825B      STD	Y+3,R5
    00843 E480      LDI	R24,0x40
    00844 E090      LDI	R25,0
    00845 E0A0      LDI	R26,0
    00846 E0B0      LDI	R27,0
    00847 8028      LD	R2,Y
    00848 8039      LDD	R3,Y+1
    00849 804A      LDD	R4,Y+2
    0084A 805B      LDD	R5,Y+3
    0084B 1628      CP	R2,R24
    0084C 0639      CPC	R3,R25
    0084D 064A      CPC	R4,R26
    0084E 065B      CPC	R5,R27
    0084F F250      BCS	0x081A
    00850 CE1E      RJMP	0x066F
    00851 9660      ADIW	R28,0x10
    00852 9149      LD	R20,Y+
    00853 9508      RET
_dis_data:
  temp_char            --> R14
  i                    --> R10
  num                  --> Y,+10
  dig_end              --> R12
  dig_start            --> R14
    00854 940E 0BC5 CALL	push_xgsetF0FC
    00856 2EC2      MOV	R12,R18
    00857 2EE0      MOV	R14,R16
(0339) 		}
(0340) 	}
(0341) }
(0342) 
(0343) 
(0344) 
(0345) 
(0346) /********************************** HD7279输入输出函数 *******************************************/
(0347) 
(0348) void dis_data ( unsigned char dig_start,unsigned char dig_end,signed long num)
(0349) {
(0350) 	unsigned char i,temp_char;
(0351) 	
(0352) 	for( i = dig_start; i <= dig_end; i++ )
    00858 2CAE      MOV	R10,R14
    00859 C036      RJMP	0x0890
(0353) 	{
(0354) 		temp_char = num % 10;
    0085A E04A      LDI	R20,0xA
    0085B E050      LDI	R21,0
    0085C E060      LDI	R22,0
    0085D E070      LDI	R23,0
    0085E 850A      LDD	R16,Y+10
    0085F 851B      LDD	R17,Y+11
    00860 852C      LDD	R18,Y+12
    00861 853D      LDD	R19,Y+13
    00862 937A      ST	-Y,R23
    00863 936A      ST	-Y,R22
    00864 935A      ST	-Y,R21
    00865 934A      ST	-Y,R20
    00866 940E 0B0F CALL	mod32s
    00868 2EE0      MOV	R14,R16
(0355) 		num -= temp_char;
    00869 2C2E      MOV	R2,R14
    0086A 2433      CLR	R3
    0086B 2444      CLR	R4
    0086C 2455      CLR	R5
    0086D 846A      LDD	R6,Y+10
    0086E 847B      LDD	R7,Y+11
    0086F 848C      LDD	R8,Y+12
    00870 849D      LDD	R9,Y+13
    00871 1862      SUB	R6,R2
    00872 0873      SBC	R7,R3
    00873 0884      SBC	R8,R4
    00874 0895      SBC	R9,R5
    00875 866A      STD	Y+10,R6
    00876 867B      STD	Y+11,R7
    00877 868C      STD	Y+12,R8
    00878 869D      STD	Y+13,R9
(0356) 		num /= 10;	
    00879 E04A      LDI	R20,0xA
    0087A E050      LDI	R21,0
    0087B E060      LDI	R22,0
    0087C E070      LDI	R23,0
    0087D 850A      LDD	R16,Y+10
    0087E 851B      LDD	R17,Y+11
    0087F 852C      LDD	R18,Y+12
    00880 853D      LDD	R19,Y+13
    00881 937A      ST	-Y,R23
    00882 936A      ST	-Y,R22
    00883 935A      ST	-Y,R21
    00884 934A      ST	-Y,R20
    00885 940E 0B0D CALL	div32s
    00887 870A      STD	Y+10,R16
    00888 871B      STD	Y+11,R17
    00889 872C      STD	Y+12,R18
    0088A 873D      STD	Y+13,R19
(0357) 		write7279 ( DECODE0 + i , 0x00 +  temp_char );//0x00为不加点显示，0x80为加点显示
    0088B 2D2E      MOV	R18,R14
    0088C 2D0A      MOV	R16,R10
    0088D 5800      SUBI	R16,0x80
    0088E DD2D      RCALL	_write7279
    0088F 94A3      INC	R10
    00890 2C2C      MOV	R2,R12
    00891 2433      CLR	R3
    00892 2C4A      MOV	R4,R10
    00893 2455      CLR	R5
    00894 1424      CP	R2,R4
    00895 0435      CPC	R3,R5
    00896 F61C      BGE	0x085A
    00897 940C 0BBA JMP	pop_xgsetF0FC
_dis_data_RP:
  temp_char            --> R14
  i                    --> R10
  rp                   --> R12
  num                  --> Y,+12
  dig_end              --> Y,+10
  dig_start            --> R14
    00899 933A      ST	-Y,R19
    0089A 932A      ST	-Y,R18
    0089B 940E 0BC5 CALL	push_xgsetF0FC
    0089D 2EE0      MOV	R14,R16
    0089E 88C8      LDD	R12,Y+16
    0089F 88D9      LDD	R13,Y+17
(0358) 
(0359) 	}
(0360) }
(0361) 
(0362) 
(0363) //带小数点显示，可以在rp位显示小数点
(0364) void dis_data_RP ( unsigned char dig_start,unsigned char dig_end,signed long num,int rp)
(0365) {
(0366) 	unsigned char i,temp_char;
(0367) 	
(0368) 	for( i = dig_start; i <= dig_end; i++ )
    008A0 2CAE      MOV	R10,R14
    008A1 C041      RJMP	0x08E3
(0369) 	{
(0370) 		temp_char = num % 10;
    008A2 E04A      LDI	R20,0xA
    008A3 E050      LDI	R21,0
    008A4 E060      LDI	R22,0
    008A5 E070      LDI	R23,0
    008A6 850C      LDD	R16,Y+12
    008A7 851D      LDD	R17,Y+13
    008A8 852E      LDD	R18,Y+14
    008A9 853F      LDD	R19,Y+15
    008AA 937A      ST	-Y,R23
    008AB 936A      ST	-Y,R22
    008AC 935A      ST	-Y,R21
    008AD 934A      ST	-Y,R20
    008AE 940E 0B0F CALL	mod32s
    008B0 2EE0      MOV	R14,R16
(0371) 		num -= temp_char;
    008B1 2C2E      MOV	R2,R14
    008B2 2433      CLR	R3
    008B3 2444      CLR	R4
    008B4 2455      CLR	R5
    008B5 846C      LDD	R6,Y+12
    008B6 847D      LDD	R7,Y+13
    008B7 848E      LDD	R8,Y+14
    008B8 849F      LDD	R9,Y+15
    008B9 1862      SUB	R6,R2
    008BA 0873      SBC	R7,R3
    008BB 0884      SBC	R8,R4
    008BC 0895      SBC	R9,R5
    008BD 866C      STD	Y+12,R6
    008BE 867D      STD	Y+13,R7
    008BF 868E      STD	Y+14,R8
    008C0 869F      STD	Y+15,R9
(0372) 		num /= 10;
    008C1 E04A      LDI	R20,0xA
    008C2 E050      LDI	R21,0
    008C3 E060      LDI	R22,0
    008C4 E070      LDI	R23,0
    008C5 850C      LDD	R16,Y+12
    008C6 851D      LDD	R17,Y+13
    008C7 852E      LDD	R18,Y+14
    008C8 853F      LDD	R19,Y+15
    008C9 937A      ST	-Y,R23
    008CA 936A      ST	-Y,R22
    008CB 935A      ST	-Y,R21
    008CC 934A      ST	-Y,R20
    008CD 940E 0B0D CALL	div32s
    008CF 870C      STD	Y+12,R16
    008D0 871D      STD	Y+13,R17
    008D1 872E      STD	Y+14,R18
    008D2 873F      STD	Y+15,R19
(0373) 		if(i!=rp)
    008D3 2C2A      MOV	R2,R10
    008D4 2433      CLR	R3
    008D5 142C      CP	R2,R12
    008D6 043D      CPC	R3,R13
    008D7 F029      BEQ	0x08DD
(0374) 		write7279 ( DECODE0 + i , 0x00 +  temp_char );//0x00为不加点显示，0x80为加点显示
    008D8 2D2E      MOV	R18,R14
    008D9 2D02      MOV	R16,R2
    008DA 5800      SUBI	R16,0x80
    008DB DCE0      RCALL	_write7279
    008DC C005      RJMP	0x08E2
(0375) 		else
(0376) 		write7279 ( DECODE0 + i , 0X80 +  temp_char );
    008DD 2D2E      MOV	R18,R14
    008DE 5820      SUBI	R18,0x80
    008DF 2D0A      MOV	R16,R10
    008E0 5800      SUBI	R16,0x80
    008E1 DCDA      RCALL	_write7279
    008E2 94A3      INC	R10
    008E3 842A      LDD	R2,Y+10
    008E4 2433      CLR	R3
    008E5 2C4A      MOV	R4,R10
    008E6 2455      CLR	R5
    008E7 1424      CP	R2,R4
    008E8 0435      CPC	R3,R5
    008E9 F00C      BLT	0x08EB
    008EA CFB7      RJMP	0x08A2
    008EB 940E 0BBA CALL	pop_xgsetF0FC
    008ED 9622      ADIW	R28,2
    008EE 9508      RET
_get_data:
  temp_long            --> Y,+0
  temp_char            --> R14
  i                    --> R10
  dig_end              --> R14
  dig_start            --> R12
    008EF 940E 0BC5 CALL	push_xgsetF0FC
    008F1 2EE2      MOV	R14,R18
    008F2 2EC0      MOV	R12,R16
    008F3 9724      SBIW	R28,4
(0377) 	}
(0378) }/**/
(0379) 
(0380) signed long get_data ( signed char dig_start,signed char dig_end )
(0381) {
(0382) 	signed long temp_long = 0;
    008F4 E080      LDI	R24,0
    008F5 8388      ST	Y,R24
    008F6 8389      STD	Y+1,R24
    008F7 838A      STD	Y+2,R24
    008F8 838B      STD	Y+3,R24
(0383) 	signed char i,temp_char;	
(0384) 	
(0385) 	for( i = dig_start; i <= dig_end; i++ )
    008F9 2CAC      MOV	R10,R12
    008FA C005      RJMP	0x0900
(0386) 		write7279(UNDECODE + i,0x08);  //显示为'_'
    008FB E028      LDI	R18,0x8
    008FC 2D0A      MOV	R16,R10
    008FD 5700      SUBI	R16,0x70
    008FE DCBD      RCALL	_write7279
    008FF 94A3      INC	R10
    00900 14EA      CP	R14,R10
    00901 F7CC      BGE	0x08FB
(0387) 		
(0388) 	for( i = dig_end; i >= dig_start ; i-- )
    00902 2CAE      MOV	R10,R14
    00903 C032      RJMP	0x0936
(0389) 	{
(0390) 		temp_char = get_key7279();
    00904 DCC5      RCALL	_get_key7279
    00905 2EE0      MOV	R14,R16
(0391) 		
(0392) 		temp_long *= 10;
    00906 8028      LD	R2,Y
    00907 8039      LDD	R3,Y+1
    00908 804A      LDD	R4,Y+2
    00909 805B      LDD	R5,Y+3
    0090A E04A      LDI	R20,0xA
    0090B E050      LDI	R21,0
    0090C E060      LDI	R22,0
    0090D E070      LDI	R23,0
    0090E 925A      ST	-Y,R5
    0090F 924A      ST	-Y,R4
    00910 923A      ST	-Y,R3
    00911 922A      ST	-Y,R2
    00912 018A      MOVW	R16,R20
    00913 019B      MOVW	R18,R22
    00914 940E 0B81 CALL	empy32u|empy32s
    00916 8308      ST	Y,R16
    00917 8319      STD	Y+1,R17
    00918 832A      STD	Y+2,R18
    00919 833B      STD	Y+3,R19
(0393) 		temp_long += temp_char;
    0091A 2C2E      MOV	R2,R14
    0091B 2433      CLR	R3
    0091C FC27      SBRC	R2,7
    0091D 9430      COM	R3
    0091E 2444      CLR	R4
    0091F FC37      SBRC	R3,7
    00920 9440      COM	R4
    00921 2455      CLR	R5
    00922 FC47      SBRC	R4,7
    00923 9450      COM	R5
    00924 8068      LD	R6,Y
    00925 8079      LDD	R7,Y+1
    00926 808A      LDD	R8,Y+2
    00927 809B      LDD	R9,Y+3
    00928 0C62      ADD	R6,R2
    00929 1C73      ADC	R7,R3
    0092A 1C84      ADC	R8,R4
    0092B 1C95      ADC	R9,R5
    0092C 8268      ST	Y,R6
    0092D 8279      STD	Y+1,R7
    0092E 828A      STD	Y+2,R8
    0092F 829B      STD	Y+3,R9
(0394) 		
(0395) 		write7279 ( DECODE1 + i , 0x80 +  temp_char); //1译码可以显示字母
    00930 2D2E      MOV	R18,R14
    00931 5820      SUBI	R18,0x80
    00932 2D0A      MOV	R16,R10
    00933 5308      SUBI	R16,0x38
    00934 DC87      RCALL	_write7279
    00935 94AA      DEC	R10
    00936 14AC      CP	R10,R12
    00937 F664      BGE	0x0904
(0396) 	}
(0397) 	delay10ms(5);
    00938 E005      LDI	R16,5
    00939 E010      LDI	R17,0
    0093A DCAC      RCALL	_delay10ms
(0398) 	send_byte(CMD_RESET);
    0093B EA04      LDI	R16,0xA4
    0093C DCC0      RCALL	_send_byte
(0399) 		
(0400) 	return temp_long;		
    0093D 8108      LD	R16,Y
    0093E 8119      LDD	R17,Y+1
    0093F 812A      LDD	R18,Y+2
    00940 813B      LDD	R19,Y+3
    00941 9624      ADIW	R28,4
    00942 940C 0BBA JMP	pop_xgsetF0FC
FILE: C:\Users\HaiPiao\Desktop\附小实验\程序\project\DS18B20\DS18B20.c
(0001) /**------------------------------------------------------------------------------
(0002) **  MCU        : ATmega16(Atmel)
(0003) **  Compiler   : ICCAVR 7.22
(0004) **  Module Name: 
(0005) **  Module Date: 
(0006) **  Module Auth: 
(0007) **  Description: 
(0008) **  Version    : V1.0
(0009) **  Notes      : 
(0010) **------------------------------------------------------------------------------
(0011) **  Version    : 
(0012) **  Modified By: 
(0013) **  Date       : 
(0014) **  Content    : 
(0015) **  Notes      : 
(0016) *******************************************************************************/
(0017) 
(0018) /*----------------------------  I N C L U D E S  -----------------------------*/
(0019) #include "DS18B20.h"
(0020) 
(0021) /*--------------------------  D E F I N I T I O N  ---------------------------*/
(0022) 
(0023) /*---------------------------  F U N C T I O N S  ----------------------------*/
(0024) /*******************************************************************************
(0025) Function Name: void DS18B20Init(void)
(0026) Author       : 
(0027) Date         : 
(0028) Description  : 
(0029) Inputs       : None
(0030) Outputs      : None
(0031) Notes        : 
(0032) Revision     : 
(0033) *******************************************************************************/
(0034) void DS18B20Init(void)  
(0035) {  
(0036) 
(0037)    DDRD|=BIT(DQ); //DQ 为输出状态
_DS18B20Init:
    00944 9A8D      SBI	0x11,5
(0038)    PORTD&=~BIT(DQ); //输出低电平
    00945 9895      CBI	0x12,5
(0039)    Delay_us1(500); //延迟500 微妙
    00946 EF04      LDI	R16,0xF4
    00947 E011      LDI	R17,1
    00948 940E 09C7 CALL	_Delay_us1
(0040)    PORTD|=BIT(DQ); //示范总线
    0094A 9A95      SBI	0x12,5
(0041)    Delay_us1(60); //延迟60 微妙
    0094B E30C      LDI	R16,0x3C
    0094C E010      LDI	R17,0
    0094D 940E 09C7 CALL	_Delay_us1
(0042)    DDRD&=~BIT(DQ); //DQ 位输入状态
    0094F 988D      CBI	0x11,5
(0043)    while(PIND&BIT(DQ)); //等待从机DS18B20 应答（低电平有效）
    00950 9985      SBIC	0x10,5
    00951 CFFE      RJMP	0x0950
(0044)    while(!(PIND&BIT(DQ)));
    00952 9B85      SBIS	0x10,5
    00953 CFFE      RJMP	0x0952
    00954 9508      RET
_write_1820:
  i                    --> R20
  Data                 --> R10
    00955 92AA      ST	-Y,R10
    00956 934A      ST	-Y,R20
    00957 2EA0      MOV	R10,R16
(0045) 
(0046) }  
(0047) /*******************************************************************************
(0048) Function Name: void write_1820(unsigned char Data)  
(0049) Author       : 
(0050) Date         : 
(0051) Description  : 
(0052) Inputs       : None
(0053) Outputs      : None
(0054) Notes        : 
(0055) Revision     : 
(0056) *******************************************************************************/
(0057) void write_1820(unsigned char Data)  
(0058) {   
(0059) 
(0060)     unsigned char i;
(0061)     DDRD|=BIT(DQ); //DQ 为输出
    00958 9A8D      SBI	0x11,5
(0062)    for(i=0;i<8;i++)
    00959 2744      CLR	R20
    0095A C017      RJMP	0x0972
(0063)    {
(0064)     PORTD&=~BIT(DQ); //拉低总线
    0095B 9895      CBI	0x12,5
(0065)     Delay_us1(10); //延迟10 微妙（最大15 微妙）
    0095C E00A      LDI	R16,0xA
    0095D E010      LDI	R17,0
    0095E 940E 09C7 CALL	_Delay_us1
(0066)     if(Data&0x01) 
    00960 FEA0      SBRS	R10,0
    00961 C002      RJMP	0x0964
(0067) 	  PORTD|=BIT(DQ);
    00962 9A95      SBI	0x12,5
    00963 C001      RJMP	0x0965
(0068)     else PORTD&=~BIT(DQ);
    00964 9895      CBI	0x12,5
(0069)       Delay_us(40); //延迟40 微妙（最大45 微妙） 
    00965 E208      LDI	R16,0x28
    00966 E010      LDI	R17,0
    00967 E020      LDI	R18,0
    00968 E030      LDI	R19,0
    00969 940E 09AD CALL	_Delay_us
(0070) 	PORTD|=BIT(DQ); //释放总线
    0096B 9A95      SBI	0x12,5
(0071)    Delay_us1(1); //稍微延迟
    0096C E001      LDI	R16,1
    0096D E010      LDI	R17,0
    0096E 940E 09C7 CALL	_Delay_us1
(0072)     Data>>=1;}
    00970 94A6      LSR	R10
    00971 9543      INC	R20
    00972 3048      CPI	R20,0x8
    00973 F338      BCS	0x095B
    00974 9149      LD	R20,Y+
    00975 90A9      LD	R10,Y+
    00976 9508      RET
_read_1820:
  Temp                 --> R20
  i                    --> R22
    00977 934A      ST	-Y,R20
    00978 936A      ST	-Y,R22
(0073) 
(0074) }  
(0075) /*******************************************************************************
(0076) Function Name: 
(0077) Author       : 
(0078) Date         : 
(0079) Description  : 
(0080) Inputs       : None
(0081) Outputs      : None
(0082) Notes        : 
(0083) Revision     : 
(0084) *******************************************************************************/
(0085) unsigned char read_1820(void)  
(0086) {   
(0087)    unsigned char i,Temp;
(0088)    for(i=0;i<8;i++)
    00979 2766      CLR	R22
    0097A C00D      RJMP	0x0988
(0089)  {
(0090)    Temp>>=1; //数据右移
    0097B 9546      LSR	R20
(0091)    DDRD|=BIT(DQ); //DQ 为输出状态
    0097C 9A8D      SBI	0x11,5
(0092)    PORTD&=~BIT(DQ); //拉低总线，启动输入
    0097D 9895      CBI	0x12,5
(0093)   PORTD|=BIT(DQ); //释放总线
    0097E 9A95      SBI	0x12,5
(0094)    DDRD&=~BIT(DQ); //DQ 为输入状态
    0097F 988D      CBI	0x11,5
(0095)   if(PIND&BIT(DQ)) 
    00980 9B85      SBIS	0x10,5
    00981 C001      RJMP	0x0983
(0096)   Temp|=0x80;
    00982 6840      ORI	R20,0x80
(0097)   Delay_us1(45); //延迟45 微妙（最大45 微妙）
    00983 E20D      LDI	R16,0x2D
    00984 E010      LDI	R17,0
    00985 940E 09C7 CALL	_Delay_us1
    00987 9563      INC	R22
    00988 3068      CPI	R22,0x8
    00989 F388      BCS	0x097B
(0098)    }
(0099) 
(0100) 
(0101) return Temp; } 
    0098A 2F04      MOV	R16,R20
    0098B 9169      LD	R22,Y+
    0098C 9149      LD	R20,Y+
    0098D 9508      RET
_gettemp:
  Temperature          --> R10
  TEM                  --> R10
  teml                 --> R10
  temh                 --> R12
    0098E 940E 0BCB CALL	push_xgset003C
(0102) 
(0103) 
(0104) 
(0105) 
(0106) /*******************************************************************************
(0107) Function Name: 
(0108) Author       : 
(0109) Date         : 
(0110) Description  : 
(0111) Inputs       : None
(0112) Outputs      : None
(0113) Notes        : 
(0114) Revision     : 
(0115) *******************************************************************************/
(0116) INT32U gettemp(void)  //读取温度值 
(0117) {  //约5 ms
(0118)      unsigned int temh,teml;  
(0119) 	 INT16U TEM;
(0120)      unsigned int  Temperature=0; //返回Tc,实际的温度T=Tc*0.1,这里用整数运算
(0121) 	
(0122)      DS18B20Init();        //复位18b20  
    00990 DFB3      RCALL	_DS18B20Init
(0123)      write_1820(0xcc);   // 发出转换命令  
    00991 EC0C      LDI	R16,0xCC
    00992 DFC2      RCALL	_write_1820
(0124)      write_1820(0x44); 
    00993 E404      LDI	R16,0x44
    00994 DFC0      RCALL	_write_1820
(0125)      
(0126)      DS18B20Init();  
    00995 DFAE      RCALL	_DS18B20Init
(0127)      write_1820(0xcc);  //发出读命令  
    00996 EC0C      LDI	R16,0xCC
    00997 DFBD      RCALL	_write_1820
(0128)      write_1820(0xbe);  
    00998 EB0E      LDI	R16,0xBE
    00999 DFBB      RCALL	_write_1820
(0129)      teml=read_1820();   
    0099A DFDC      RCALL	_read_1820
    0099B 2EA0      MOV	R10,R16
    0099C 24BB      CLR	R11
(0130)      temh=read_1820();  //读数据
    0099D DFD9      RCALL	_read_1820
    0099E 2EC0      MOV	R12,R16
    0099F 24DD      CLR	R13
(0131) 	 
(0132) 	 TEM = ((temh<<8)|teml);
    009A0 0116      MOVW	R2,R12
    009A1 2C32      MOV	R3,R2
    009A2 2422      CLR	R2
    009A3 282A      OR	R2,R10
    009A4 283B      OR	R3,R11
    009A5 0151      MOVW	R10,R2
(0133) 	/* if((1<<15)&(TEM))//等于1，表示为负
(0134) 	 {
(0135) 	  TEM = ((1<<12)-(TEM&~(0X1F<<15)));//负数求补码
(0136) 	 } 
(0137) 	 else
(0138) 	 {
(0139) 	  TEM = ((temh<<8)|teml);
(0140) 	 }*/	 	 
(0141) 	 DS18B20Init(); 
    009A6 DF9D      RCALL	_DS18B20Init
(0142) 	 return TEM;//*6.25;//(((temh<<8)|teml)*6.25);
    009A7 0185      MOVW	R16,R10
    009A8 0196      MOVW	R18,R12
    009A9 2722      CLR	R18
    009AA 2733      CLR	R19
    009AB 940C 0BB5 JMP	pop_xgset003C
_Delay_us:
  i                    --> R20
  n                    --> Y,+2
    009AD 940E 0AC1 CALL	push_arg4
    009AF 934A      ST	-Y,R20
    009B0 935A      ST	-Y,R21
FILE: C:\Users\HaiPiao\Desktop\附小实验\程序\project\Delay\Delay.c
(0001) /*******************************************************************************
(0002) **  Copyright (c)   2011       USTB MEI
(0003) **                  All Rights Reserved
(0004) **  
(0005) **  
(0006) **-----------------------------------------------------------------------------
(0007) **  MCU        : ATmega16 (Atmel)
(0008) **  Compiler   : ICCAVR 7.22
(0009) **  Module Name: Delay.c
(0010) **  Module Date: 2011-03-28
(0011) **  Module Auth: 吴勤兵
(0012) **  Description: Delay functions for ATmega16 at 7.3728MHz
(0013) **  Version    : V1.0
(0014) **  Notes      : These delay functions are suited for ATmega8 at 7.3728MHz.
(0015) **------------------------------------------------------------------------------
(0016) **  Version    : 
(0017) **  Modified By: 
(0018) **  Date       : 
(0019) **  Content    : 
(0020) **  Notes      : 
(0021) *******************************************************************************/
(0022) 
(0023) /*----------------------------  I N C L U D E S  -----------------------------*/
(0024) #include "Delay.h"
(0025) 
(0026) /*--------------------------  D E F I N I T I O N  ---------------------------*/
(0027) 
(0028) /*---------------------------  F U N C T I O N S  ----------------------------*/
(0029) /*******************************************************************************
(0030) Function Name: Delay_us
(0031) Author       : 吴勤兵
(0032) Date         : 2011-03-14
(0033) Description  : Delay n us
(0034) Inputs       : UINT16 n -- n us
(0035) Outputs      : None
(0036) Notes        : 
(0037) Revision     : 
(0038) *******************************************************************************/
(0039) void Delay_us(INT32U n)
(0040) {          
(0041)     unsigned int i = 0;	
(0042)     for(i = 0; i < n; i++)
    009B1 2744      CLR	R20
    009B2 2755      CLR	R21
    009B3 C003      RJMP	0x09B7
(0043)     {
(0044)         NOP();
    009B4 0000      NOP
    009B5 5F4F      SUBI	R20,0xFF
    009B6 4F5F      SBCI	R21,0xFF
    009B7 802A      LDD	R2,Y+2
    009B8 803B      LDD	R3,Y+3
    009B9 804C      LDD	R4,Y+4
    009BA 805D      LDD	R5,Y+5
    009BB 013A      MOVW	R6,R20
    009BC 2488      CLR	R8
    009BD 2499      CLR	R9
    009BE 1462      CP	R6,R2
    009BF 0473      CPC	R7,R3
    009C0 0484      CPC	R8,R4
    009C1 0495      CPC	R9,R5
    009C2 F388      BCS	0x09B4
    009C3 9159      LD	R21,Y+
    009C4 9149      LD	R20,Y+
    009C5 9624      ADIW	R28,4
    009C6 9508      RET
_Delay_us1:
  j                    --> R10
  i                    --> R20
  n                    --> R16
    009C7 940E 0BD0 CALL	push_xgset300C
(0045)     }
(0046) }
(0047) 
(0048) 
(0049) void Delay_us1(int n)
(0050) {          
(0051)     int i = 0;
(0052)     int j = 0;
    009C9 24AA      CLR	R10
    009CA 24BB      CLR	R11
(0053) 	
(0054)     for(i = 0; i < n; i++)
    009CB 2744      CLR	R20
    009CC 2755      CLR	R21
    009CD C00A      RJMP	0x09D8
(0055)     {
(0056)          NOP();
    009CE 0000      NOP
(0057) 		 NOP();
    009CF 0000      NOP
(0058) 		 NOP();
    009D0 0000      NOP
(0059) 		 NOP();
    009D1 0000      NOP
(0060) 		 NOP();
    009D2 0000      NOP
(0061) 		 NOP();
    009D3 0000      NOP
(0062) 		 NOP();
    009D4 0000      NOP
(0063) 		 NOP();		
    009D5 0000      NOP
    009D6 5F4F      SUBI	R20,0xFF
    009D7 4F5F      SBCI	R21,0xFF
    009D8 1740      CP	R20,R16
    009D9 0751      CPC	R21,R17
    009DA F39C      BLT	0x09CE
    009DB 940C 0BD5 JMP	pop_xgset300C
_Delay_ms:
  i                    --> R20
  j                    --> R22
  n                    --> R16
    009DD 940E 0BDA CALL	push_xgsetF000
(0064)     }
(0065) }
(0066) 
(0067) /*******************************************************************************
(0068) Function Name: Delay_ms
(0069) Author       : 吴勤兵
(0070) Date         : 2011-03-14
(0071) Description  : Delay n ms
(0072) Inputs       : UINT16 n -- n ms
(0073) Outputs      : None
(0074) Notes        : 
(0075) Revision     : 
(0076) *******************************************************************************/
(0077) void Delay_ms(unsigned int n)
(0078) {          
(0079)     unsigned int i = 0;
(0080)     unsigned int j = 0;
    009DF 2766      CLR	R22
    009E0 2777      CLR	R23
(0081) 	
(0082)     for(i = 0; i < n; i++)
    009E1 2744      CLR	R20
    009E2 2755      CLR	R21
    009E3 C00B      RJMP	0x09EF
(0083)     {
(0084)         for(j = 0; j < 2100; j++)
    009E4 2766      CLR	R22
    009E5 2777      CLR	R23
    009E6 C002      RJMP	0x09E9
    009E7 5F6F      SUBI	R22,0xFF
    009E8 4F7F      SBCI	R23,0xFF
    009E9 3364      CPI	R22,0x34
    009EA E0E8      LDI	R30,0x8
    009EB 077E      CPC	R23,R30
    009EC F3D0      BCS	0x09E7
    009ED 5F4F      SUBI	R20,0xFF
    009EE 4F5F      SBCI	R21,0xFF
    009EF 1740      CP	R20,R16
    009F0 0751      CPC	R21,R17
    009F1 F390      BCS	0x09E4
    009F2 940C 0BDF JMP	pop_xgsetF000
_Delay_ms1:
  i                    --> R20
  j                    --> R22
  n                    --> R16
    009F4 940E 0BDA CALL	push_xgsetF000
(0085)         {
(0086)             // Delay n ms
(0087)         }
(0088)     }
(0089) }
(0090) 
(0091) void Delay_ms1(int n)
(0092) {          
(0093)     int i = 0;
(0094)     int j = 0;
    009F6 2766      CLR	R22
    009F7 2777      CLR	R23
(0095) 	
(0096)     for(i = 0; i < n; i++)
    009F8 2744      CLR	R20
    009F9 2755      CLR	R21
    009FA C00A      RJMP	0x0A05
(0097)     {
(0098)         for(j = 0; j < 2000; j++)
    009FB 2766      CLR	R22
    009FC 2777      CLR	R23
    009FD 5F6F      SUBI	R22,0xFF
    009FE 4F7F      SBCI	R23,0xFF
    009FF 3D60      CPI	R22,0xD0
    00A00 E0E7      LDI	R30,7
    00A01 077E      CPC	R23,R30
    00A02 F3D4      BLT	0x09FD
    00A03 5F4F      SUBI	R20,0xFF
    00A04 4F5F      SBCI	R21,0xFF
    00A05 1740      CP	R20,R16
    00A06 0751      CPC	R21,R17
    00A07 F39C      BLT	0x09FB
    00A08 940C 0BDF JMP	pop_xgsetF000
FILE: C:\Users\HaiPiao\Desktop\附小实验\程序\project\HC_SR04\HC_SR04.c
(0001) /*******************************************************************************
(0002) **  MCU        : ATmega16 (Atmel)
(0003) **  Compiler   : ICCAVR 7.22
(0004) **  Module Name: HC_SR04.c
(0005) **  Module Date: 2015-10-22
(0006) **  Module Auth: 蔡海飘
(0007) **  Description: 超声波传感器
(0008) **  Version    : V1.0
(0009) **  Notes      : 
(0010) **------------------------------------------------------------------------------
(0011) /*----------------------------  I N C L U D E S  -----------------------------*/
(0012) #include "HC_SR04.h"
(0013) /*--------------------------  D E F I N I T I O N  ---------------------------*/
(0014) //#define basic_Frequency 7.3728*10^6
(0015) 
(0016) 
(0017) unsigned char TimerOut_Flag = 0;
(0018) /*---------------------------  F U N C T I O N S  ----------------------------*/
(0019) void HC_SR04_Init(void)
(0020) {
(0021)  	 DDRD |= (0x01<<3);//TRIG output
_HC_SR04_Init:
    00A0A 9A8B      SBI	0x11,3
(0022) 	 DDRD &= ~(0x01<<4);//ECHO input
    00A0B 988C      CBI	0x11,4
(0023) 	 PORTD &=~(0X01<<3);//TRIG output LOW
    00A0C 9893      CBI	0x12,3
    00A0D 9508      RET
(0024) }  
(0025) 
(0026) //TIMER1 initialize - prescale:1
(0027) // WGM: 0) Normal, TOP=0xFFFF
(0028) // desired value: 1KHz
(0029) // actual value:  1.000KHz (0.0%)
(0030) void timer1_init(void)
(0031) {
(0032)  TCCR1B = 0x00; //stop
_timer1_init:
    00A0E 2422      CLR	R2
    00A0F BC2E      OUT	0x2E,R2
(0033)  TCNT1H = 0x00; //setup
    00A10 BC2D      OUT	0x2D,R2
(0034)  TCNT1L = 0x00;
    00A11 BC2C      OUT	0x2C,R2
(0035)  OCR1AH = 0xE0;
    00A12 EE80      LDI	R24,0xE0
    00A13 BD8B      OUT	0x2B,R24
(0036)  OCR1AL = 0xFF;
    00A14 EF8F      LDI	R24,0xFF
    00A15 BD8A      OUT	0x2A,R24
(0037)  OCR1BH = 0xE0;
    00A16 EE80      LDI	R24,0xE0
    00A17 BD89      OUT	0x29,R24
(0038)  OCR1BL = 0xFF;
    00A18 EF8F      LDI	R24,0xFF
    00A19 BD88      OUT	0x28,R24
(0039)  ICR1H  = 0xE0;
    00A1A EE80      LDI	R24,0xE0
    00A1B BD87      OUT	0x27,R24
(0040)  ICR1L  = 0xFF;
    00A1C EF8F      LDI	R24,0xFF
    00A1D BD86      OUT	0x26,R24
(0041)  TCCR1A = 0x00;
    00A1E BC2F      OUT	0x2F,R2
(0042)  TCCR1B = 0x00; //start Timer
    00A1F BC2E      OUT	0x2E,R2
    00A20 9508      RET
_timer1_ovf_isr:
    00A21 922A      ST	-Y,R2
    00A22 938A      ST	-Y,R24
    00A23 B62F      IN	R2,0x3F
    00A24 922A      ST	-Y,R2
(0043) }
(0044) 
(0045) #pragma interrupt_handler timer1_ovf_isr:iv_TIM1_OVF
(0046) void timer1_ovf_isr(void)
(0047) {
(0048)  //TIMER1 has overflowed
(0049)  TCNT1H = 0x00; //reload counter high value
    00A25 2422      CLR	R2
    00A26 BC2D      OUT	0x2D,R2
(0050)  TCNT1L = 0x00; //reload counter low value
    00A27 BC2C      OUT	0x2C,R2
(0051)  //PORTC ^= (0X01<<6);
(0052)  TimerOut_Flag = 1;
    00A28 E081      LDI	R24,1
    00A29 9380 03F9 STS	TimerOut_Flag,R24
(0053)  TCCR1B = 0x00; //stop
    00A2B BC2E      OUT	0x2E,R2
    00A2C 9029      LD	R2,Y+
    00A2D BE2F      OUT	0x3F,R2
    00A2E 9189      LD	R24,Y+
    00A2F 9029      LD	R2,Y+
    00A30 9518      RETI
_GetDistance:
  Time                 --> R10
  distance             --> Y,+0
    00A31 92AA      ST	-Y,R10
    00A32 92BA      ST	-Y,R11
    00A33 9724      SBIW	R28,4
(0054)  
(0055) }
(0056) 
(0057) float GetDistance(void)
(0058) {
(0059)     float distance = 0;
    00A34 EA04      LDI	R16,0xA4
    00A35 E010      LDI	R17,0
    00A36 940E 0C20 CALL	lpm32
    00A38 8308      ST	Y,R16
    00A39 8319      STD	Y+1,R17
    00A3A 832A      STD	Y+2,R18
    00A3B 833B      STD	Y+3,R19
(0060) 	INT16U Time = 0;
    00A3C 24AA      CLR	R10
    00A3D 24BB      CLR	R11
(0061) 	TimerOut_Flag = 0;
    00A3E 2422      CLR	R2
    00A3F 9220 03F9 STS	TimerOut_Flag,R2
(0062) 	TRIG_High;
    00A41 9A93      SBI	0x12,3
(0063) 	Delay_us(10);
    00A42 E00A      LDI	R16,0xA
    00A43 E010      LDI	R17,0
    00A44 E020      LDI	R18,0
    00A45 E030      LDI	R19,0
    00A46 940E 09AD CALL	_Delay_us
(0064) 	TRIG_Low;
    00A48 9893      CBI	0x12,3
(0065) 	while(!ECHO_Read);//wait ECHO output high
    00A49 9B84      SBIS	0x10,4
    00A4A CFFE      RJMP	0x0A49
(0066) 	TCNT1H = 0x0; //reload counter high value
    00A4B 2422      CLR	R2
    00A4C BC2D      OUT	0x2D,R2
(0067)     TCNT1L = 0x0; //reload counter low value
    00A4D BC2C      OUT	0x2C,R2
(0068) 	TCCR1B = 0x01; //start Timer}
    00A4E E081      LDI	R24,1
    00A4F BD8E      OUT	0x2E,R24
(0069) 	while(ECHO_Read&&!TimerOut_Flag);//  wait ECHO output low or time out
    00A50 9B84      SBIS	0x10,4
    00A51 C004      RJMP	0x0A56
    00A52 9020 03F9 LDS	R2,TimerOut_Flag
    00A54 2022      TST	R2
    00A55 F3D1      BEQ	0x0A50
(0070) 	TCCR1B = 0x00; //stop
    00A56 2422      CLR	R2
    00A57 BC2E      OUT	0x2E,R2
(0071) 	if(TimerOut_Flag)                                  
    00A58 9020 03F9 LDS	R2,TimerOut_Flag
    00A5A 2022      TST	R2
    00A5B F029      BEQ	0x0A61
(0072) 	{
(0073) 	   Time = 0xffff;
    00A5C EF8F      LDI	R24,0xFF
    00A5D EF9F      LDI	R25,0xFF
    00A5E 015C      MOVW	R10,R24
(0074) 	   PORTC |= (0X01<<6);   
    00A5F 9AAE      SBI	0x15,6
(0075) 	}
    00A60 C003      RJMP	0x0A64
(0076) 	else
(0077) 	{
(0078) 	   Time = TCNT1;
    00A61 B4AC      IN	R10,0x2C
    00A62 B4BD      IN	R11,0x2D
(0079) 	   PORTC &= ~(0X01<<6);
    00A63 98AE      CBI	0x15,6
(0080) 	}   
(0081) 	   
(0082) 	distance = ((float)Time)*170*1000/7372800;
    00A64 EA00      LDI	R16,0xA0
    00A65 E010      LDI	R17,0
    00A66 940E 0C20 CALL	lpm32
    00A68 0118      MOVW	R2,R16
    00A69 0129      MOVW	R4,R18
    00A6A E90C      LDI	R16,0x9C
    00A6B E010      LDI	R17,0
    00A6C 940E 0C20 CALL	lpm32
    00A6E 0138      MOVW	R6,R16
    00A6F 0149      MOVW	R8,R18
    00A70 0185      MOVW	R16,R10
    00A71 940E 0C6D CALL	uint2fp
    00A73 933A      ST	-Y,R19
    00A74 932A      ST	-Y,R18
    00A75 931A      ST	-Y,R17
    00A76 930A      ST	-Y,R16
    00A77 0183      MOVW	R16,R6
    00A78 0194      MOVW	R18,R8
    00A79 940E 0E15 CALL	fpmule2x
    00A7B 0181      MOVW	R16,R2
    00A7C 0192      MOVW	R18,R4
    00A7D 940E 0E0A CALL	fpmule2
    00A7F 0118      MOVW	R2,R16
    00A80 0129      MOVW	R4,R18
    00A81 E908      LDI	R16,0x98
    00A82 E010      LDI	R17,0
    00A83 940E 0C20 CALL	lpm32
    00A85 933A      ST	-Y,R19
    00A86 932A      ST	-Y,R18
    00A87 931A      ST	-Y,R17
    00A88 930A      ST	-Y,R16
    00A89 0181      MOVW	R16,R2
    00A8A 0192      MOVW	R18,R4
    00A8B 940E 0C9A CALL	fpdiv2
    00A8D 8308      ST	Y,R16
    00A8E 8319      STD	Y+1,R17
    00A8F 832A      STD	Y+2,R18
    00A90 833B      STD	Y+3,R19
(0083) 	return distance;
    00A91 8108      LD	R16,Y
    00A92 8119      LDD	R17,Y+1
    00A93 812A      LDD	R18,Y+2
    00A94 813B      LDD	R19,Y+3
    00A95 9624      ADIW	R28,4
    00A96 90B9      LD	R11,Y+
    00A97 90A9      LD	R10,Y+
    00A98 9508      RET
FILE: C:\Users\HaiPiao\Desktop\附小实验\程序\project\MQ_2\MQ_2.c
(0001) /*******************************************************************************
(0002) **  MCU        : ATmega16 (Atmel)
(0003) **  Compiler   : ICCAVR 7.22
(0004) **  Module Name: MH_B.c
(0005) **  Module Date: 2015-10-16
(0006) **  Module Auth: 蔡海飘
(0007) **  Description: 气体传感器
(0008) **  Version    : V1.0
(0009) **  Notes      : 
(0010) **------------------------------------------------------------------------------
(0011) /*----------------------------  I N C L U D E S  -----------------------------*/
(0012) #include "MQ_2.h"
(0013) 
(0014) /*--------------------------  D E F I N I T I O N  ---------------------------*/
(0015) #define MQ2_DO_PNUM 		0
(0016) #define MQ2_DO_DDR 			DDRD
(0017) #define MQ2_DO_PIN 			PIND
(0018) 
(0019) #define MQ2_AO_PNUM 		1
(0020) #define MQ2_AO_DDR 			DDRA
(0021) #define MQ2_AO_PIN 			PINA
(0022) /*---------------------------  F U N C T I O N S  ----------------------------*/
(0023) void MQ2_Init(void)
(0024) {
(0025)  	 MQ2_DO_DDR &= ~(0x01<<MQ2_DO_PNUM);
_MQ2_Init:
    00A99 9888      CBI	0x11,0
(0026) 	 MQ2_AO_DDR &= ~(0x01<<MQ2_AO_PNUM);
    00A9A 98D1      CBI	0x1A,1
(0027) 	 
(0028) 	 ADCSR = 0x00; //disable adc
    00A9B 2422      CLR	R2
    00A9C B826      OUT	0x06,R2
(0029)  	 ADMUX |= (0x01<<0)|(0x01<<5)|(0x01<<6); //select adc input 1,左对齐，参考电压AVCC， AREF 引脚外加滤波电容
    00A9D B187      IN	R24,0x07
    00A9E 6681      ORI	R24,0x61
    00A9F B987      OUT	0x07,R24
(0030)  	 ACSR  = 0x80;
    00AA0 E880      LDI	R24,0x80
    00AA1 B988      OUT	0x08,R24
(0031)  	 ADCSR |= (0x01<<7);//ADC enable
    00AA2 9A37      SBI	0x06,7
    00AA3 9508      RET
(0032) }  
(0033) 
(0034) unsigned char Read_MQ2_DO(void)  
(0035) {
(0036)     unsigned char state = 0;
_Read_MQ2_DO:
  state                --> R16
    00AA4 2700      CLR	R16
(0037) 	state = MQ2_DO_PIN&(0x01<<MQ2_DO_PNUM);
    00AA5 B300      IN	R16,0x10
    00AA6 7001      ANDI	R16,1
(0038) 	return state;
    00AA7 9508      RET
_Read_MQ2_AO:
  state                --> R10
    00AA8 92AA      ST	-Y,R10
    00AA9 92BA      ST	-Y,R11
(0039) }
(0040) 
(0041) INT16U Read_MQ2_AO(void)  
(0042) {
(0043)     INT16U state = 0;
    00AAA 24AA      CLR	R10
    00AAB 24BB      CLR	R11
(0044) 	ADCSR |= (0x01<<6);//convert start
    00AAC 9A36      SBI	0x06,6
(0045) 	while(ADCSR&(0x01<<6));//wait convert end
    00AAD 9936      SBIC	0x06,6
    00AAE CFFE      RJMP	0x0AAD
(0046) 	state = (ADCH<<2)|(ADCL>>6);
    00AAF E026      LDI	R18,6
    00AB0 E030      LDI	R19,0
    00AB1 B104      IN	R16,0x04
    00AB2 2711      CLR	R17
    00AB3 940E 0AC6 CALL	asr16
    00AB5 B0A5      IN	R10,0x05
    00AB6 24BB      CLR	R11
    00AB7 0CAA      LSL	R10
    00AB8 1CBB      ROL	R11
    00AB9 0CAA      LSL	R10
    00ABA 1CBB      ROL	R11
    00ABB 2AA0      OR	R10,R16
    00ABC 2AB1      OR	R11,R17
(0047) 	return state;
FILE: <library>
    00ABD 0185      MOVW	R16,R10
    00ABE 90B9      LD	R11,Y+
    00ABF 90A9      LD	R10,Y+
    00AC0 9508      RET
push_arg4:
    00AC1 933A      ST	-Y,R19
    00AC2 932A      ST	-Y,R18
push_arg2:
    00AC3 931A      ST	-Y,R17
    00AC4 930A      ST	-Y,R16
    00AC5 9508      RET
asr16:
    00AC6 2322      TST	R18
    00AC7 F021      BEQ	0x0ACC
    00AC8 9515      ASR	R17
    00AC9 9507      ROR	R16
    00ACA 952A      DEC	R18
    00ACB CFFA      RJMP	asr16
    00ACC 9508      RET
mod16s:
    00ACD 9468      BSET	6
    00ACE 92DA      ST	-Y,R13
    00ACF 2ED1      MOV	R13,R17
    00AD0 C004      RJMP	0x0AD5
div16s:
    00AD1 94E8      BCLR	6
    00AD2 92DA      ST	-Y,R13
    00AD3 2ED1      MOV	R13,R17
    00AD4 26D3      EOR	R13,R19
    00AD5 FF17      SBRS	R17,7
    00AD6 C004      RJMP	0x0ADB
    00AD7 9510      COM	R17
    00AD8 9500      COM	R16
    00AD9 5F0F      SUBI	R16,0xFF
    00ADA 4F1F      SBCI	R17,0xFF
    00ADB FF37      SBRS	R19,7
    00ADC C004      RJMP	0x0AE1
    00ADD 9530      COM	R19
    00ADE 9520      COM	R18
    00ADF 5F2F      SUBI	R18,0xFF
    00AE0 4F3F      SBCI	R19,0xFF
    00AE1 940E 0AEE CALL	xdiv16u
    00AE3 FED7      SBRS	R13,7
    00AE4 C004      RJMP	0x0AE9
    00AE5 9510      COM	R17
    00AE6 9500      COM	R16
    00AE7 5F0F      SUBI	R16,0xFF
    00AE8 4F1F      SBCI	R17,0xFF
    00AE9 90D9      LD	R13,Y+
    00AEA 9508      RET
mod16u:
    00AEB 9468      BSET	6
    00AEC C001      RJMP	xdiv16u
div16u:
    00AED 94E8      BCLR	6
xdiv16u:
    00AEE 92EA      ST	-Y,R14
    00AEF 92FA      ST	-Y,R15
    00AF0 938A      ST	-Y,R24
    00AF1 24EE      CLR	R14
    00AF2 24FF      CLR	R15
    00AF3 E180      LDI	R24,0x10
    00AF4 0F00      LSL	R16
    00AF5 1F11      ROL	R17
    00AF6 1CEE      ROL	R14
    00AF7 1CFF      ROL	R15
    00AF8 16E2      CP	R14,R18
    00AF9 06F3      CPC	R15,R19
    00AFA F018      BCS	0x0AFE
    00AFB 1AE2      SUB	R14,R18
    00AFC 0AF3      SBC	R15,R19
    00AFD 9503      INC	R16
    00AFE 958A      DEC	R24
    00AFF F7A1      BNE	0x0AF4
    00B00 F416      BRTC	0x0B03
    00B01 2D0E      MOV	R16,R14
    00B02 2D1F      MOV	R17,R15
    00B03 9189      LD	R24,Y+
    00B04 90F9      LD	R15,Y+
    00B05 90E9      LD	R14,Y+
    00B06 9508      RET
div32u:
    00B07 94E8      BCLR	6
    00B08 C001      RJMP	0x0B0A
mod32u:
    00B09 9468      BSET	6
    00B0A D030      RCALL	long_div_prolog
    00B0B 24CC      CLR	R12
    00B0C C009      RJMP	0x0B16
div32s:
    00B0D 94E8      BCLR	6
    00B0E C001      RJMP	0x0B10
mod32s:
    00B0F 9468      BSET	6
    00B10 D02A      RCALL	long_div_prolog
    00B11 FD37      SBRC	R19,7
    00B12 940E 0BF2 CALL	neg32
    00B14 FDB7      SBRC	R27,7
    00B15 D052      RCALL	neg_R24_R27
    00B16 2477      CLR	R7
    00B17 2488      CLR	R8
    00B18 2499      CLR	R9
    00B19 24AA      CLR	R10
    00B1A 24BB      CLR	R11
    00B1B D042      RCALL	tst_R16_R19
    00B1C F0C1      BEQ	0x0B35
    00B1D D045      RCALL	tst_R24_R27
    00B1E F0B1      BEQ	0x0B35
    00B1F E2E8      LDI	R30,0x28
    00B20 0F00      LSL	R16
    00B21 1F11      ROL	R17
    00B22 1F22      ROL	R18
    00B23 1F33      ROL	R19
    00B24 1C77      ROL	R7
    00B25 1C88      ROL	R8
    00B26 1C99      ROL	R9
    00B27 1CAA      ROL	R10
    00B28 1CBB      ROL	R11
    00B29 1688      CP	R8,R24
    00B2A 0699      CPC	R9,R25
    00B2B 06AA      CPC	R10,R26
    00B2C 06BB      CPC	R11,R27
    00B2D F028      BCS	0x0B33
    00B2E 1A88      SUB	R8,R24
    00B2F 0A99      SBC	R9,R25
    00B30 0AAA      SBC	R10,R26
    00B31 0ABB      SBC	R11,R27
    00B32 9503      INC	R16
    00B33 95EA      DEC	R30
    00B34 F759      BNE	0x0B20
    00B35 F426      BRTC	0x0B3A
    00B36 2D08      MOV	R16,R8
    00B37 2D19      MOV	R17,R9
    00B38 2D2A      MOV	R18,R10
    00B39 2D3B      MOV	R19,R11
    00B3A C013      RJMP	long_div_epilog
long_div_prolog:
    00B3B 927A      ST	-Y,R7
    00B3C 928A      ST	-Y,R8
    00B3D 929A      ST	-Y,R9
    00B3E 92AA      ST	-Y,R10
    00B3F 92BA      ST	-Y,R11
    00B40 92CA      ST	-Y,R12
    00B41 93EA      ST	-Y,R30
    00B42 938A      ST	-Y,R24
    00B43 939A      ST	-Y,R25
    00B44 93AA      ST	-Y,R26
    00B45 93BA      ST	-Y,R27
    00B46 858B      LDD	R24,Y+11
    00B47 859C      LDD	R25,Y+12
    00B48 85AD      LDD	R26,Y+13
    00B49 85BE      LDD	R27,Y+14
    00B4A 2EC3      MOV	R12,R19
    00B4B F00E      BRTS	0x0B4D
    00B4C 26CB      EOR	R12,R27
    00B4D 9508      RET
long_div_epilog:
    00B4E FCC7      SBRC	R12,7
    00B4F 940E 0BF2 CALL	neg32
    00B51 91B9      LD	R27,Y+
    00B52 91A9      LD	R26,Y+
    00B53 9199      LD	R25,Y+
    00B54 9189      LD	R24,Y+
    00B55 91E9      LD	R30,Y+
    00B56 90C9      LD	R12,Y+
    00B57 90B9      LD	R11,Y+
    00B58 90A9      LD	R10,Y+
    00B59 9099      LD	R9,Y+
    00B5A 9089      LD	R8,Y+
    00B5B 9079      LD	R7,Y+
    00B5C 9624      ADIW	R28,4
    00B5D 9508      RET
tst_R16_R19:
    00B5E 2FE0      MOV	R30,R16
    00B5F 2BE1      OR	R30,R17
    00B60 2BE2      OR	R30,R18
    00B61 2BE3      OR	R30,R19
    00B62 9508      RET
tst_R24_R27:
    00B63 2FE8      MOV	R30,R24
    00B64 2BE9      OR	R30,R25
    00B65 2BEA      OR	R30,R26
    00B66 2BEB      OR	R30,R27
    00B67 9508      RET
neg_R24_R27:
    00B68 9580      COM	R24
    00B69 9590      COM	R25
    00B6A 95A0      COM	R26
    00B6B 95B0      COM	R27
    00B6C 5F8F      SUBI	R24,0xFF
    00B6D 4F9F      SBCI	R25,0xFF
    00B6E 4FAF      SBCI	R26,0xFF
    00B6F 4FBF      SBCI	R27,0xFF
    00B70 9508      RET
empy16s:
    00B71 920A      ST	-Y,R0
    00B72 921A      ST	-Y,R1
    00B73 938A      ST	-Y,R24
    00B74 939A      ST	-Y,R25
    00B75 9F02      MUL	R16,R18
    00B76 01C0      MOVW	R24,R0
    00B77 9F12      MUL	R17,R18
    00B78 0D90      ADD	R25,R0
    00B79 9F03      MUL	R16,R19
    00B7A 0D90      ADD	R25,R0
    00B7B 018C      MOVW	R16,R24
    00B7C 9199      LD	R25,Y+
    00B7D 9189      LD	R24,Y+
    00B7E 9019      LD	R1,Y+
    00B7F 9009      LD	R0,Y+
    00B80 9508      RET
empy32u|empy32s:
    00B81 940E 0BFB CALL	long_prolog
    00B83 927A      ST	-Y,R7
    00B84 940E 0C14 CALL	tstzero1
    00B86 F159      BEQ	0x0BB2
    00B87 2477      CLR	R7
    00B88 940E 0C1A CALL	tstzero2
    00B8A F419      BNE	0x0B8E
    00B8B 018C      MOVW	R16,R24
    00B8C 019D      MOVW	R18,R26
    00B8D C024      RJMP	0x0BB2
    00B8E 920A      ST	-Y,R0
    00B8F 921A      ST	-Y,R1
    00B90 9F08      MUL	R16,R24
    00B91 2CB0      MOV	R11,R0
    00B92 2CA1      MOV	R10,R1
    00B93 9F28      MUL	R18,R24
    00B94 2C90      MOV	R9,R0
    00B95 2C81      MOV	R8,R1
    00B96 9F18      MUL	R17,R24
    00B97 0CA0      ADD	R10,R0
    00B98 1C91      ADC	R9,R1
    00B99 1C87      ADC	R8,R7
    00B9A 9F09      MUL	R16,R25
    00B9B 0CA0      ADD	R10,R0
    00B9C 1C91      ADC	R9,R1
    00B9D 1C87      ADC	R8,R7
    00B9E 9F19      MUL	R17,R25
    00B9F 0C90      ADD	R9,R0
    00BA0 1C81      ADC	R8,R1
    00BA1 9F0A      MUL	R16,R26
    00BA2 0C90      ADD	R9,R0
    00BA3 1C81      ADC	R8,R1
    00BA4 9F38      MUL	R19,R24
    00BA5 0C80      ADD	R8,R0
    00BA6 9F29      MUL	R18,R25
    00BA7 0C80      ADD	R8,R0
    00BA8 9F1A      MUL	R17,R26
    00BA9 0C80      ADD	R8,R0
    00BAA 9F0B      MUL	R16,R27
    00BAB 0C80      ADD	R8,R0
    00BAC 9019      LD	R1,Y+
    00BAD 9009      LD	R0,Y+
    00BAE 2D0B      MOV	R16,R11
    00BAF 2D1A      MOV	R17,R10
    00BB0 2D29      MOV	R18,R9
    00BB1 2D38      MOV	R19,R8
    00BB2 9079      LD	R7,Y+
    00BB3 940C 0C09 JMP	long_epilog
pop_xgset003C:
    00BB5 90A9      LD	R10,Y+
    00BB6 90B9      LD	R11,Y+
    00BB7 90C9      LD	R12,Y+
    00BB8 90D9      LD	R13,Y+
    00BB9 9508      RET
pop_xgsetF0FC:
    00BBA 90A9      LD	R10,Y+
    00BBB 90B9      LD	R11,Y+
    00BBC 90C9      LD	R12,Y+
    00BBD 90D9      LD	R13,Y+
    00BBE 90E9      LD	R14,Y+
    00BBF 90F9      LD	R15,Y+
    00BC0 9149      LD	R20,Y+
    00BC1 9159      LD	R21,Y+
    00BC2 9169      LD	R22,Y+
    00BC3 9179      LD	R23,Y+
    00BC4 9508      RET
push_xgsetF0FC:
    00BC5 937A      ST	-Y,R23
    00BC6 936A      ST	-Y,R22
push_xgset30FC:
    00BC7 935A      ST	-Y,R21
    00BC8 934A      ST	-Y,R20
push_xgset00FC:
    00BC9 92FA      ST	-Y,R15
    00BCA 92EA      ST	-Y,R14
push_xgset003C:
    00BCB 92DA      ST	-Y,R13
    00BCC 92CA      ST	-Y,R12
    00BCD 92BA      ST	-Y,R11
    00BCE 92AA      ST	-Y,R10
    00BCF 9508      RET
push_xgset300C:
    00BD0 935A      ST	-Y,R21
    00BD1 934A      ST	-Y,R20
    00BD2 92BA      ST	-Y,R11
    00BD3 92AA      ST	-Y,R10
    00BD4 9508      RET
pop_xgset300C:
    00BD5 90A9      LD	R10,Y+
    00BD6 90B9      LD	R11,Y+
    00BD7 9149      LD	R20,Y+
    00BD8 9159      LD	R21,Y+
    00BD9 9508      RET
push_xgsetF000:
    00BDA 937A      ST	-Y,R23
    00BDB 936A      ST	-Y,R22
    00BDC 935A      ST	-Y,R21
    00BDD 934A      ST	-Y,R20
    00BDE 9508      RET
pop_xgsetF000:
    00BDF 9149      LD	R20,Y+
    00BE0 9159      LD	R21,Y+
    00BE1 9169      LD	R22,Y+
    00BE2 9179      LD	R23,Y+
    00BE3 9508      RET
push_xgsetF00C:
    00BE4 937A      ST	-Y,R23
    00BE5 936A      ST	-Y,R22
    00BE6 935A      ST	-Y,R21
    00BE7 934A      ST	-Y,R20
    00BE8 92BA      ST	-Y,R11
    00BE9 92AA      ST	-Y,R10
    00BEA 9508      RET
pop_xgsetF00C:
    00BEB 90A9      LD	R10,Y+
    00BEC 90B9      LD	R11,Y+
    00BED 9149      LD	R20,Y+
    00BEE 9159      LD	R21,Y+
    00BEF 9169      LD	R22,Y+
    00BF0 9179      LD	R23,Y+
    00BF1 9508      RET
neg32:
    00BF2 9500      COM	R16
    00BF3 9510      COM	R17
    00BF4 9520      COM	R18
    00BF5 9530      COM	R19
    00BF6 5F0F      SUBI	R16,0xFF
    00BF7 4F1F      SBCI	R17,0xFF
    00BF8 4F2F      SBCI	R18,0xFF
    00BF9 4F3F      SBCI	R19,0xFF
    00BFA 9508      RET
long_prolog:
    00BFB 928A      ST	-Y,R8
    00BFC 929A      ST	-Y,R9
    00BFD 92AA      ST	-Y,R10
    00BFE 92BA      ST	-Y,R11
    00BFF 93EA      ST	-Y,R30
    00C00 938A      ST	-Y,R24
    00C01 939A      ST	-Y,R25
    00C02 93AA      ST	-Y,R26
    00C03 93BA      ST	-Y,R27
    00C04 8589      LDD	R24,Y+9
    00C05 859A      LDD	R25,Y+10
    00C06 85AB      LDD	R26,Y+11
    00C07 85BC      LDD	R27,Y+12
    00C08 9508      RET
long_epilog:
    00C09 91B9      LD	R27,Y+
    00C0A 91A9      LD	R26,Y+
    00C0B 9199      LD	R25,Y+
    00C0C 9189      LD	R24,Y+
    00C0D 91E9      LD	R30,Y+
    00C0E 90B9      LD	R11,Y+
    00C0F 90A9      LD	R10,Y+
    00C10 9099      LD	R9,Y+
    00C11 9089      LD	R8,Y+
    00C12 9624      ADIW	R28,4
    00C13 9508      RET
tstzero1:
    00C14 27EE      CLR	R30
    00C15 2BE0      OR	R30,R16
    00C16 2BE1      OR	R30,R17
    00C17 2BE2      OR	R30,R18
    00C18 2BE3      OR	R30,R19
    00C19 9508      RET
tstzero2:
    00C1A 27EE      CLR	R30
    00C1B 2BE8      OR	R30,R24
    00C1C 2BE9      OR	R30,R25
    00C1D 2BEA      OR	R30,R26
    00C1E 2BEB      OR	R30,R27
    00C1F 9508      RET
lpm32:
    00C20 93EA      ST	-Y,R30
    00C21 93FA      ST	-Y,R31
    00C22 920A      ST	-Y,R0
    00C23 2FE0      MOV	R30,R16
    00C24 2FF1      MOV	R31,R17
    00C25 95C8      LPM
    00C26 2D00      MOV	R16,R0
    00C27 9631      ADIW	R30,1
    00C28 95C8      LPM
    00C29 2D10      MOV	R17,R0
    00C2A 9631      ADIW	R30,1
    00C2B 95C8      LPM
    00C2C 2D20      MOV	R18,R0
    00C2D 9631      ADIW	R30,1
    00C2E 95C8      LPM
    00C2F 2D30      MOV	R19,R0
    00C30 9009      LD	R0,Y+
    00C31 91F9      LD	R31,Y+
    00C32 91E9      LD	R30,Y+
    00C33 9508      RET
lsl16:
    00C34 2322      TST	R18
    00C35 F021      BEQ	0x0C3A
    00C36 0F00      LSL	R16
    00C37 1F11      ROL	R17
    00C38 952A      DEC	R18
    00C39 CFFA      RJMP	lsl16
    00C3A 9508      RET
fpint:
    00C3B 924A      ST	-Y,R4
    00C3C 925A      ST	-Y,R5
    00C3D 926A      ST	-Y,R6
    00C3E 938A      ST	-Y,R24
    00C3F 940E 0D3B CALL	unpacku
    00C41 F111      BEQ	0x0C64
    00C42 2055      TST	R5
    00C43 F0E2      BMI	0x0C60
    00C44 E18F      LDI	R24,0x1F
    00C45 1648      CP	R4,R24
    00C46 F4C0      BCC	0x0C5F
    00C47 E187      LDI	R24,0x17
    00C48 1648      CP	R4,R24
    00C49 F0D1      BEQ	0x0C64
    00C4A F458      BCC	0x0C56
    00C4B 9441      NEG	R4
    00C4C EE89      LDI	R24,0xE9
    00C4D 1A48      SUB	R4,R24
    00C4E C005      RJMP	0x0C54
    00C4F 9535      ASR	R19
    00C50 9527      ROR	R18
    00C51 9517      ROR	R17
    00C52 9507      ROR	R16
    00C53 944A      DEC	R4
    00C54 F7D1      BNE	0x0C4F
    00C55 C00E      RJMP	0x0C64
    00C56 E187      LDI	R24,0x17
    00C57 1A48      SUB	R4,R24
    00C58 0F00      LSL	R16
    00C59 1F11      ROL	R17
    00C5A 1F22      ROL	R18
    00C5B 1F33      ROL	R19
    00C5C 944A      DEC	R4
    00C5D F7D1      BNE	0x0C58
    00C5E C005      RJMP	0x0C64
    00C5F E73F      LDI	R19,0x7F
    00C60 2F23      MOV	R18,R19
    00C61 2F13      MOV	R17,R19
    00C62 2F03      MOV	R16,R19
    00C63 C004      RJMP	0x0C68
    00C64 2066      TST	R6
    00C65 F011      BEQ	0x0C68
    00C66 940E 0BF2 CALL	neg32
    00C68 9189      LD	R24,Y+
    00C69 9069      LD	R6,Y+
    00C6A 9059      LD	R5,Y+
    00C6B 9049      LD	R4,Y+
    00C6C 9508      RET
uint2fp:
    00C6D 9468      BSET	6
    00C6E C001      RJMP	0x0C70
int2fp:
    00C6F 94E8      BCLR	6
    00C70 2722      CLR	R18
    00C71 2733      CLR	R19
    00C72 F046      BRTS	0x0C7B
    00C73 FD17      SBRC	R17,7
    00C74 9520      COM	R18
    00C75 FD17      SBRC	R17,7
    00C76 9530      COM	R19
    00C77 C003      RJMP	0x0C7B
ulong2fp:
    00C78 9468      BSET	6
    00C79 C001      RJMP	0x0C7B
long2fp:
    00C7A 94E8      BCLR	6
    00C7B 924A      ST	-Y,R4
    00C7C 925A      ST	-Y,R5
    00C7D 926A      ST	-Y,R6
    00C7E 938A      ST	-Y,R24
    00C7F E187      LDI	R24,0x17
    00C80 2E48      MOV	R4,R24
    00C81 2455      CLR	R5
    00C82 2466      CLR	R6
    00C83 F036      BRTS	0x0C8A
    00C84 2333      TST	R19
    00C85 F422      BPL	0x0C8A
    00C86 940E 0BF2 CALL	neg32
    00C88 E880      LDI	R24,0x80
    00C89 2E68      MOV	R6,R24
    00C8A 940E 0D54 CALL	normalize_and_pack
    00C8C 9189      LD	R24,Y+
    00C8D 9069      LD	R6,Y+
    00C8E 9059      LD	R5,Y+
    00C8F 9049      LD	R4,Y+
    00C90 9508      RET
fpdiv1:
    00C91 93FA      ST	-Y,R31
    00C92 93EA      ST	-Y,R30
    00C93 81EA      LDD	R30,Y+2
    00C94 81FB      LDD	R31,Y+3
    00C95 D027      RCALL	0x0CBD
    00C96 91E9      LD	R30,Y+
    00C97 91F9      LD	R31,Y+
    00C98 9622      ADIW	R28,2
    00C99 9508      RET
fpdiv2:
    00C9A 93FA      ST	-Y,R31
    00C9B 93EA      ST	-Y,R30
    00C9C 2FEC      MOV	R30,R28
    00C9D 2FFD      MOV	R31,R29
    00C9E 9632      ADIW	R30,2
    00C9F D01D      RCALL	0x0CBD
    00CA0 91E9      LD	R30,Y+
    00CA1 91F9      LD	R31,Y+
    00CA2 9624      ADIW	R28,4
    00CA3 9508      RET
fpdiv1x:
    00CA4 93FA      ST	-Y,R31
    00CA5 93EA      ST	-Y,R30
    00CA6 81EA      LDD	R30,Y+2
    00CA7 81FB      LDD	R31,Y+3
    00CA8 D014      RCALL	0x0CBD
    00CA9 91E9      LD	R30,Y+
    00CAA 91F9      LD	R31,Y+
    00CAB 8339      STD	Y+1,R19
    00CAC 8328      ST	Y,R18
    00CAD 931A      ST	-Y,R17
    00CAE 930A      ST	-Y,R16
    00CAF 9508      RET
fpdiv2x:
    00CB0 93FA      ST	-Y,R31
    00CB1 93EA      ST	-Y,R30
    00CB2 2FEC      MOV	R30,R28
    00CB3 2FFD      MOV	R31,R29
    00CB4 9632      ADIW	R30,2
    00CB5 D007      RCALL	0x0CBD
    00CB6 91E9      LD	R30,Y+
    00CB7 91F9      LD	R31,Y+
    00CB8 833B      STD	Y+3,R19
    00CB9 832A      STD	Y+2,R18
    00CBA 8319      STD	Y+1,R17
    00CBB 8308      ST	Y,R16
    00CBC 9508      RET
    00CBD 920A      ST	-Y,R0
    00CBE 921A      ST	-Y,R1
    00CBF 922A      ST	-Y,R2
    00CC0 923A      ST	-Y,R3
    00CC1 940E 0D99 CALL	saveFPRegs
    00CC3 933A      ST	-Y,R19
    00CC4 932A      ST	-Y,R18
    00CC5 931A      ST	-Y,R17
    00CC6 930A      ST	-Y,R16
    00CC7 8100      LD	R16,Z
    00CC8 8111      LDD	R17,Z+1
    00CC9 8122      LDD	R18,Z+2
    00CCA 8133      LDD	R19,Z+3
    00CCB 940E 0D3B CALL	unpacku
    00CCD F409      BNE	0x0CCF
    00CCE C057      RJMP	0x0D26
    00CCF 2CE6      MOV	R14,R6
    00CD0 2CD5      MOV	R13,R5
    00CD1 2CC4      MOV	R12,R4
    00CD2 2EB3      MOV	R11,R19
    00CD3 2EA2      MOV	R10,R18
    00CD4 2E91      MOV	R9,R17
    00CD5 2E80      MOV	R8,R16
    00CD6 9109      LD	R16,Y+
    00CD7 9119      LD	R17,Y+
    00CD8 9129      LD	R18,Y+
    00CD9 9139      LD	R19,Y+
    00CDA 940E 0D3B CALL	unpacku
    00CDC F1A1      BEQ	0x0D11
    00CDD 246E      EOR	R6,R14
    00CDE 184C      SUB	R4,R12
    00CDF 085D      SBC	R5,R13
    00CE0 E880      LDI	R24,0x80
    00CE1 1648      CP	R4,R24
    00CE2 0653      CPC	R5,R19
    00CE3 F00C      BLT	0x0CE5
    00CE4 C033      RJMP	0x0D18
    00CE5 E881      LDI	R24,0x81
    00CE6 1648      CP	R4,R24
    00CE7 EF8F      LDI	R24,0xFF
    00CE8 0658      CPC	R5,R24
    00CE9 F40C      BGE	0x0CEB
    00CEA C036      RJMP	0x0D21
    00CEB E280      LDI	R24,0x20
    00CEC 2433      CLR	R3
    00CED 2E23      MOV	R2,R19
    00CEE 2E12      MOV	R1,R18
    00CEF 2E01      MOV	R0,R17
    00CF0 2F30      MOV	R19,R16
    00CF1 2722      CLR	R18
    00CF2 2711      CLR	R17
    00CF3 2700      CLR	R16
    00CF4 9426      LSR	R2
    00CF5 9417      ROR	R1
    00CF6 9407      ROR	R0
    00CF7 9537      ROR	R19
    00CF8 9527      ROR	R18
    00CF9 0F00      LSL	R16
    00CFA 1F11      ROL	R17
    00CFB 1F22      ROL	R18
    00CFC 1F33      ROL	R19
    00CFD 1C00      ROL	R0
    00CFE 1C11      ROL	R1
    00CFF 1C22      ROL	R2
    00D00 1C33      ROL	R3
    00D01 F028      BCS	0x0D07
    00D02 1808      SUB	R0,R8
    00D03 0819      SBC	R1,R9
    00D04 082A      SBC	R2,R10
    00D05 083B      SBC	R3,R11
    00D06 C004      RJMP	0x0D0B
    00D07 0C08      ADD	R0,R8
    00D08 1C19      ADC	R1,R9
    00D09 1C2A      ADC	R2,R10
    00D0A 1C3B      ADC	R3,R11
    00D0B F00A      BMI	0x0D0D
    00D0C 6001      ORI	R16,1
    00D0D 958A      DEC	R24
    00D0E F751      BNE	0x0CF9
    00D0F 940E 0D54 CALL	normalize_and_pack
    00D11 940E 0DA8 CALL	restoreFPRegs
    00D13 9039      LD	R3,Y+
    00D14 9029      LD	R2,Y+
    00D15 9019      LD	R1,Y+
    00D16 9009      LD	R0,Y+
    00D17 9508      RET
    00D18 EF0F      LDI	R16,0xFF
    00D19 2F10      MOV	R17,R16
    00D1A E72F      LDI	R18,0x7F
    00D1B E73F      LDI	R19,0x7F
    00D1C 2066      TST	R6
    00D1D F399      BEQ	0x0D11
    00D1E 940E 0BF2 CALL	neg32
    00D20 CFF0      RJMP	0x0D11
    00D21 2700      CLR	R16
    00D22 2F10      MOV	R17,R16
    00D23 2F20      MOV	R18,R16
    00D24 2F30      MOV	R19,R16
    00D25 CFEB      RJMP	0x0D11
    00D26 9109      LD	R16,Y+
    00D27 9119      LD	R17,Y+
    00D28 9129      LD	R18,Y+
    00D29 9139      LD	R19,Y+
    00D2A CFED      RJMP	0x0D18
unpacks:
    00D2B D00F      RCALL	unpacku
    00D2C F029      BEQ	0x0D32
    00D2D 2066      TST	R6
    00D2E F011      BEQ	0x0D31
    00D2F 940E 0BF2 CALL	neg32
    00D31 9498      BCLR	1
    00D32 9508      RET
tstR16_R19:
    00D33 2300      TST	R16
    00D34 F429      BNE	0x0D3A
    00D35 2311      TST	R17
    00D36 F419      BNE	0x0D3A
    00D37 2322      TST	R18
    00D38 F409      BNE	0x0D3A
    00D39 2333      TST	R19
    00D3A 9508      RET
unpacku:
    00D3B DFF7      RCALL	tstR16_R19
    00D3C F099      BEQ	0x0D50
    00D3D 938A      ST	-Y,R24
    00D3E 2E63      MOV	R6,R19
    00D3F E880      LDI	R24,0x80
    00D40 2268      AND	R6,R24
    00D41 0F22      LSL	R18
    00D42 1F33      ROL	R19
    00D43 2E43      MOV	R4,R19
    00D44 E78F      LDI	R24,0x7F
    00D45 1A48      SUB	R4,R24
    00D46 2455      CLR	R5
    00D47 2788      CLR	R24
    00D48 0A58      SBC	R5,R24
    00D49 9526      LSR	R18
    00D4A E830      LDI	R19,0x80
    00D4B 2B23      OR	R18,R19
    00D4C 2733      CLR	R19
    00D4D 9189      LD	R24,Y+
    00D4E 9498      BCLR	1
    00D4F 9508      RET
    00D50 2444      CLR	R4
    00D51 2455      CLR	R5
    00D52 2466      CLR	R6
    00D53 9508      RET
normalize_and_pack:
    00D54 DFDE      RCALL	tstR16_R19
    00D55 F409      BNE	0x0D57
    00D56 9508      RET
    00D57 93AA      ST	-Y,R26
    00D58 93BA      ST	-Y,R27
    00D59 01D2      MOVW	R26,R4
    00D5A 939A      ST	-Y,R25
    00D5B 938A      ST	-Y,R24
    00D5C E78E      LDI	R24,0x7E
    00D5D E090      LDI	R25,0
    00D5E 2333      TST	R19
    00D5F F049      BEQ	0x0D69
    00D60 9536      LSR	R19
    00D61 9527      ROR	R18
    00D62 9517      ROR	R17
    00D63 9507      ROR	R16
    00D64 17A8      CP	R26,R24
    00D65 07B9      CPC	R27,R25
    00D66 F4CC      BGE	0x0D80
    00D67 9611      ADIW	R26,1
    00D68 CFF5      RJMP	0x0D5E
    00D69 9580      COM	R24
    00D6A 9590      COM	R25
    00D6B 9601      ADIW	R24,1
    00D6C 2322      TST	R18
    00D6D F0BA      BMI	0x0D85
    00D6E 0F00      LSL	R16
    00D6F 1F11      ROL	R17
    00D70 1F22      ROL	R18
    00D71 17A8      CP	R26,R24
    00D72 07B9      CPC	R27,R25
    00D73 F014      BLT	0x0D76
    00D74 9711      SBIW	R26,1
    00D75 CFF6      RJMP	0x0D6C
    00D76 2700      CLR	R16
    00D77 2711      CLR	R17
    00D78 2722      CLR	R18
    00D79 2733      CLR	R19
    00D7A 9189      LD	R24,Y+
    00D7B 9199      LD	R25,Y+
    00D7C 012D      MOVW	R4,R26
    00D7D 91B9      LD	R27,Y+
    00D7E 91A9      LD	R26,Y+
    00D7F 9508      RET
    00D80 2733      CLR	R19
    00D81 EF0F      LDI	R16,0xFF
    00D82 2F10      MOV	R17,R16
    00D83 E72F      LDI	R18,0x7F
    00D84 2F32      MOV	R19,R18
    00D85 9189      LD	R24,Y+
    00D86 9199      LD	R25,Y+
    00D87 012D      MOVW	R4,R26
    00D88 C002      RJMP	0x0D8B
pack:
    00D89 93AA      ST	-Y,R26
    00D8A 93BA      ST	-Y,R27
    00D8B DFA7      RCALL	tstR16_R19
    00D8C F049      BEQ	0x0D96
    00D8D 01D2      MOVW	R26,R4
    00D8E 58A1      SUBI	R26,0x81
    00D8F 4FBF      SBCI	R27,0xFF
    00D90 012D      MOVW	R4,R26
    00D91 2D34      MOV	R19,R4
    00D92 0F22      LSL	R18
    00D93 9536      LSR	R19
    00D94 9527      ROR	R18
    00D95 2936      OR	R19,R6
    00D96 91B9      LD	R27,Y+
    00D97 91A9      LD	R26,Y+
    00D98 9508      RET
saveFPRegs:
    00D99 924A      ST	-Y,R4
    00D9A 925A      ST	-Y,R5
    00D9B 926A      ST	-Y,R6
    00D9C 927A      ST	-Y,R7
    00D9D 928A      ST	-Y,R8
    00D9E 929A      ST	-Y,R9
    00D9F 92AA      ST	-Y,R10
    00DA0 92BA      ST	-Y,R11
    00DA1 92CA      ST	-Y,R12
    00DA2 92DA      ST	-Y,R13
    00DA3 92EA      ST	-Y,R14
    00DA4 92FA      ST	-Y,R15
    00DA5 938A      ST	-Y,R24
    00DA6 939A      ST	-Y,R25
    00DA7 9508      RET
restoreFPRegs:
    00DA8 9199      LD	R25,Y+
    00DA9 9189      LD	R24,Y+
    00DAA 90F9      LD	R15,Y+
    00DAB 90E9      LD	R14,Y+
    00DAC 90D9      LD	R13,Y+
    00DAD 90C9      LD	R12,Y+
    00DAE 90B9      LD	R11,Y+
    00DAF 90A9      LD	R10,Y+
    00DB0 9099      LD	R9,Y+
    00DB1 9089      LD	R8,Y+
    00DB2 9079      LD	R7,Y+
    00DB3 9069      LD	R6,Y+
    00DB4 9059      LD	R5,Y+
    00DB5 9049      LD	R4,Y+
    00DB6 9508      RET
fpmule:
    00DB7 940E 0D99 CALL	saveFPRegs
    00DB9 93AA      ST	-Y,R26
    00DBA 93BA      ST	-Y,R27
    00DBB 940E 0D3B CALL	unpacku
    00DBD F1E1      BEQ	0x0DFA
    00DBE 2CE6      MOV	R14,R6
    00DBF 2CD5      MOV	R13,R5
    00DC0 2CC4      MOV	R12,R4
    00DC1 2EB3      MOV	R11,R19
    00DC2 2EA2      MOV	R10,R18
    00DC3 2E91      MOV	R9,R17
    00DC4 2E80      MOV	R8,R16
    00DC5 8100      LD	R16,Z
    00DC6 8111      LDD	R17,Z+1
    00DC7 8122      LDD	R18,Z+2
    00DC8 8133      LDD	R19,Z+3
    00DC9 940E 0D3B CALL	unpacku
    00DCB F171      BEQ	0x0DFA
    00DCC 246E      EOR	R6,R14
    00DCD 0C4C      ADD	R4,R12
    00DCE 1C5D      ADC	R5,R13
    00DCF E880      LDI	R24,0x80
    00DD0 1648      CP	R4,R24
    00DD1 0653      CPC	R5,R19
    00DD2 F564      BGE	0x0DFF
    00DD3 E881      LDI	R24,0x81
    00DD4 1648      CP	R4,R24
    00DD5 EF8F      LDI	R24,0xFF
    00DD6 0658      CPC	R5,R24
    00DD7 F16C      BLT	0x0E05
    00DD8 9EA2      MUL	R10,R18
    00DD9 2DB1      MOV	R27,R1
    00DDA 2DA0      MOV	R26,R0
    00DDB 9E91      MUL	R9,R17
    00DDC 2D91      MOV	R25,R1
    00DDD 2D80      MOV	R24,R0
    00DDE 9EA0      MUL	R10,R16
    00DDF 0D80      ADD	R24,R0
    00DE0 1D91      ADC	R25,R1
    00DE1 1FA3      ADC	R26,R19
    00DE2 1FB3      ADC	R27,R19
    00DE3 9E82      MUL	R8,R18
    00DE4 0D80      ADD	R24,R0
    00DE5 1D91      ADC	R25,R1
    00DE6 1FA3      ADC	R26,R19
    00DE7 1FB3      ADC	R27,R19
    00DE8 9E92      MUL	R9,R18
    00DE9 0D90      ADD	R25,R0
    00DEA 1DA1      ADC	R26,R1
    00DEB 1FB3      ADC	R27,R19
    00DEC 9EA1      MUL	R10,R17
    00DED 0D90      ADD	R25,R0
    00DEE 1DA1      ADC	R26,R1
    00DEF 1FB3      ADC	R27,R19
    00DF0 2F2B      MOV	R18,R27
    00DF1 2F1A      MOV	R17,R26
    00DF2 2F09      MOV	R16,R25
    00DF3 0F88      LSL	R24
    00DF4 1F00      ROL	R16
    00DF5 1F11      ROL	R17
    00DF6 1F22      ROL	R18
    00DF7 1F33      ROL	R19
    00DF8 940E 0D54 CALL	normalize_and_pack
    00DFA 91B9      LD	R27,Y+
    00DFB 91A9      LD	R26,Y+
    00DFC 940E 0DA8 CALL	restoreFPRegs
    00DFE 9508      RET
    00DFF EF0F      LDI	R16,0xFF
    00E00 2F10      MOV	R17,R16
    00E01 E72F      LDI	R18,0x7F
    00E02 E78F      LDI	R24,0x7F
    00E03 2E48      MOV	R4,R24
    00E04 CFF5      RJMP	0x0DFA
    00E05 2700      CLR	R16
    00E06 2F10      MOV	R17,R16
    00E07 2F20      MOV	R18,R16
    00E08 2F30      MOV	R19,R16
    00E09 CFF0      RJMP	0x0DFA
fpmule2:
    00E0A 93FA      ST	-Y,R31
    00E0B 93EA      ST	-Y,R30
    00E0C 2FEC      MOV	R30,R28
    00E0D 2FFD      MOV	R31,R29
    00E0E 9632      ADIW	R30,2
    00E0F 940E 0DB7 CALL	fpmule
    00E11 91E9      LD	R30,Y+
    00E12 91F9      LD	R31,Y+
    00E13 9624      ADIW	R28,4
    00E14 9508      RET
fpmule2x:
    00E15 93FA      ST	-Y,R31
    00E16 93EA      ST	-Y,R30
    00E17 2FEC      MOV	R30,R28
    00E18 2FFD      MOV	R31,R29
    00E19 9632      ADIW	R30,2
    00E1A 940E 0DB7 CALL	fpmule
    00E1C 91E9      LD	R30,Y+
    00E1D 91F9      LD	R31,Y+
    00E1E 833B      STD	Y+3,R19
    00E1F 832A      STD	Y+2,R18
    00E20 8319      STD	Y+1,R17
    00E21 8308      ST	Y,R16
    00E22 9508      RET
